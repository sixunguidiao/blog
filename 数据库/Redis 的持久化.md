# Redis 持久化

Redis 有两种持久化的方式：快照（`RDB`文件）和追加式文件（`AOF`文件）：

- RDB 持久化方式会在一个特定的间隔保存那个时间点的一个数据快照；
- AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存；
- Redis 的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里；
- 两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据；

## RDB

### 工作原理

- Redis 调用 fork()，产生一个子进程；
- 子进程把数据写到一个临时的 RDB 文件；
- 当子进程写完新的 RDB 文件后，把旧的 RDB 文件替换掉；

### 优点

- RDB 文件是一个很简洁的单文件，它保存了某个时间点的 Redis 中的数据，很适合用于做备份。你可以设定一个时间点对 RDB 文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本；
- 基于上面所描述的特性，RDB 很适合用于容灾备份。单文件很方便就能传输到远程的服务器上；
- RDB 的性能很好，需要进行持久化时，主进程会 fork 一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的 I/O 操作；
- 比起 AOF，在数据量比较大的情况下，RDB 的启动速度更快；

### 缺点

- RDB 容易造成数据的丢失。假设每5分钟保存一次快照，如果 Redis 因为某些原因不能正常工作，那么从上次产生快照到 Redis 出现问题这段时间的数据就会丢失了。
- RDB 使用`fork()`产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成 Redis 停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒。

### 保存点 (RDB 的启用和禁用)

你可以配置保存点，使 Redis 如果在每 N 秒后数据发生了 M 次改变就保存快照文件。例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，Redis 就会自动保存快照文件：

```
save 60 1000
```

保存点可以设置多个，Redis 的配置文件就默认设置了3个保存点：

```
# 格式为：save <seconds> <changes>
# 可以设置多个。
save 900 1 # 900秒后至少1个key有变动
save 300 10 # 300秒后至少10个key有变动
save 60 10000 # 60秒后至少10000个key有变动
```

如果想禁用快照保存的功能，可以通过注释掉所有"save"配置达到，或者在最后一条"save"配置后添加如下的配置：

```
save ""
```

### 手动生成快照

Redis 提供了两个命令用于手动生成快照。

#### SAVE

SAVE 命令会使用同步的方式生成 RDB 快照文件，这意味着在这个过程中会阻塞所有其他客户端的请求。因此不建议在生产环境使用这个命令。

#### BGSAVE

BGSAVE 命令使用后台的方式保存 RDB 文件，调用此命令后，会立刻返回`OK`返回码。Redis 会产生一个子进程进行处理并立刻恢复对客户端的服务。在客户端我们可以使用 LASTSAVE 命令查看操作是否成功。

```
127.0.0.1:6379> BGSAVE
Background saving started
127.0.0.1:6379> LASTSAVE
(integer) 1433936394
```

> 配置文件里禁用了快照生成功能不影响`SAVE`和`BGSAVE`命令的效果。

## AOF

快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而 AOF 文件则提供了一种更为可靠的持久化方式。每当 Redis 接受到会修改数据集的命令时，就会把命令追加到 AOF 文件里，当你重启 Redis 时，AOF 里的命令会被重新执行一次，重建数据。

### 优点

- 比 RDB 可靠。你可以制定不同的 fsync (将文件数据同步到磁盘) 策略：不进行 fsync、每秒 fsync 一次和每次查询进行 fsync。默认是每秒 fsync 一次。这意味着你最多丢失一秒钟的数据；
- AOF 日志文件是一个纯追加的文件。就算是遇到突然停电的情况，也不会出现日志的定位或者损坏问题。甚至如果因为某些原因（例如磁盘满了）命令只写了一半到日志文件里，我们也可以用`redis-check-aof`这个工具很简单的进行修复；
- 当 AOF 文件太大时，Redis 会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis 会继续往旧的文件追加数据。新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis 会把新旧文件进行切换，然后开始把数据写到新文件上。
- AOF 把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。例如我们不小心用`FLUSHALL`命令把所有数据刷掉了，只要文件没有被重写，我们可以把服务停掉，把最后那条命令删掉，然后重启服务，这样就能把被刷掉的数据恢复回来。

### 缺点

- 在相同的数据集下，AOF 文件的大小一般会比 RDB 文件大。
- 在某些 fsync 策略下，AOF 的速度会比 RDB 慢。通常 fsync 设置为每秒一次就能获得比较高的性能，而在禁止 fsync 的情况下速度可以达到 RDB 的水平。

### 可靠性

你可以配置 Redis 调用 fsync 的频率，有三个选项：

- 每当有新命令追加到 AOF 的时候调用 fsync。速度最慢，但是最安全。
- 每秒 fsync 一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据）。
- 从不 fsync，交由系统去处理。这个方式速度最快，但是安全性一般。

推荐使用每秒 fsync 一次的方式（默认的方式），因为它速度快，安全性也不错。

### 日志重写

随着写操作的不断增加，AOF 文件会越来越大。例如你递增一个计数器100次，那么最终结果就是数据集里的计数器的值为最终的递增结果，但是 AOF 文件里却会把这100次操作完整的记录下来。而事实上要恢复这个记录，只需要1个命令就行了，也就是说 AOF 文件里那100条命令其实可以精简为1条。所以 Redis 支持这样一个功能：在不中断服务的情况下在后台重建 AOF 文件。

工作原理如下：

- Redis 调用 fork()，产生一个子进程。
- 子进程把新的 AOF 写到一个临时文件里 (新文件的内容是能重建当前数据集的最小操作命令的集合)。
- 主进程持续把新的变动写到内存里的 buffer，同时也会把这些新的变动写到旧的 AOF 里，这样即使重写失败也能保证数据的安全。
- 当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的 buffer 追加到子进程生成的那个新 AOF 里。

