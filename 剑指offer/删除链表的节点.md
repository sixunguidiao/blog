# 题目

给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。输入保证要删除的节点在链表中。

# 思路

当要删除的节点node不是链表的尾节点时，我们可以先把该节点的下一个节点next的值赋给node，然后令node的next指向next的next即可。当要删除的节点是链表的尾节点时，我们就不能这么做了，需要从从链表头开始顺序地查找该节点并删除。

```java
public ListNode deleteNode(ListNode head, ListNode node) {
    if (head == null || head.next == null) return null;
    if (node == null) return head;
    if (node.next != null) {	// 如果node不是链表的尾节点
        ListNode next = node.next;
        node.val = next.val;
        node.next = next.next;
        next = null;	// 便于被GC发现
    } else { // 如果node是链表的尾节点
        ListNode curr = head;
        while (curr.next != node) {
            curr = curr.next;
        }
        curr.next = null;
        node = null;	// 便于被GC发现
    }
    return head;
}
```

# 扩展1

在一个排序的链表中，删除重复的结点。例如给定链表`1->2->3->3->4->4->5`，删除重复节点后的链表为`1->2->5`。

# 思路

首先注意到头结点也有可能是重复节点，也有可能被删除，因此函数的返回值应该为ListNode。我们从头开始遍历整个链表，用curr指示当前节点，prev指示当前节点的前一个节点，next指示当前节点的下一个节点，如果curr和next的值不同，我们移动只需要移动curr和prev继续判断下一个节点即可；当curr和next相同，说明curr和next是重复节点，由于链表是排好序的，因此重复节点是连续的，我们找到第一个比curr大的节点并把该节点赋值给next，让prev指向next即删除了所有和curr的值相同的重复节点。注意在将prev指向next时，prev可能为null，这说明头结点是重复节点，此时我们需要把next赋值给head以作为新的头节点。

```java
public ListNode deleteDuplicatedNodes(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        boolean isDuplicated = false;	// 指示curr和next是否是重复节点
        if (next != null && curr.val == next.val) isDuplicated = true;
        if (!isDuplicated) {	// 如果curr和next不是重复节点，继续判断下一个节点
            prev = curr;
            curr = next;
        } else {	// 如果curr和next是重复节点，找到第一个比curr的值大的节点并将其赋值给next
            ListNode temp = next;
            while (temp != null && temp.val == curr.val) {
                temp = temp.next;
            }
            next = temp;
            if (prev == null) {	// 如果头节点是重复节点，将next作为新的头节点
                head = next;
            } else {	// 否则，将prev指向next
                prev.next = next;
            }
            curr = next;
        }
    }
    return head;
}
```

# 扩展2

给定一个单链表，删除链表中所有节点值为target的节点，返回删除后链表的头节点。例如给定链表`1->2->3->3->4->4->5`，删除值为3的节点后的链表为`1->2->4->4->5`。

# 思路

大体思路同上，用prev, curr, next分别表示前一个节点，当前节点和下一个节点。遍历链表，如果当前节点的值不等于target，移动prev和curr继续判断下一个节点；否则，我们需要将prev的next指向next以删除当前节点，如果prev为null，说明头结点是需要删除的节点，将next赋给head。

```java
public ListNode deleteNodes(ListNode head, int target) {
    if (head == null) return null;
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        if (curr.val == target) {
            if (prev == null) {
                head = next;
            } else {
                prev.next = next;
            }
            curr = next;
        } else {
            prev = curr;
            curr = next;
        }
    }
    return head;
}
```

