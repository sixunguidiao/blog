# 题目

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）。例如给定树A：

```
    8
   / \
  8   7
 / \
9   2
   / \
  4   7
```

树B：

```
  8
 / \
9   2
```

可知B是A的子结构。

# 思路

首先在root1中找到和root2的根节点的值一样的节点，然后判断该节点所代表的子树是不是和root2具有相同的结构。

```java
public boolean hasSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null && root2 == null) return true;	// 约定当root1和root2均为null，root2是root1的子结构，返回true
    if (root1 == null || root2 == null) return false;
    boolean isFound = false;
    if (root1.val == root2.val) isFound = helper(root1, root2);
    if (!isFound) isFound = hasSubtree(root1.left, root2) || hasSubtree(root1.right, root2);
    return isFound;
}

private boolean helper(TreeNode root1, TreeNode root2) {
    if (root2 == null) return true;	// 如果root2 == null，说明root1和root2之前的结构完全相同，这时就算root1 != null，也可以返回true
    if (root1 == null) return false;	// 如果roo1 == null，借由上一条语句知root2 != null，所以root1和root2的结构不相同，返回false
    if (root1.val != root2.val) return false;
    return helper(root1.left, root2.left) && helper(root1.right, root2.right);
}
```

# 扩展

LeetCode 572。和一题不同的是，这要求树B和树A中的某个子树完全相同。例如给定树A：

```
     3
    / \
   4   5
  / \
 1   2
```

树B：

```
   4 
  / \
 1   2
```

返回true。而给定树A：

```
     3
    / \
   4   5
  / \
 1   2
    /
   0
```

树B：

```
   4
  / \
 1   2
```

返回false。

# 思路

上一题中假设在A中找到了和B的根节点的值相同的节点root后，只要求root所代表的子树中包含和B的结构完全一样的**结构**即可。而这里要求root所代表的子树和B**完全一样**，即root及其所有后继节点都要和B完全一样。两者的区别在`helper()`函数的不同。

```java
public boolean hasSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null && root2 == null) return true;
    if (root1 == null || root2 == null) return false;
    boolean isFound = false;
    if (root1.val == root2.val) isFound = helper(root1, root2);
    if (!isFound) isFound = hasSubtree(root1.left, root2) || hasSubtree(root1.right, root2);
    return isFound;
}

private boolean helper(TreeNode root1, TreeNode root2) {
    // root1和root2同时访问到null才返回true，一个为null一个不为null或者两个节点的val值不相同都返回false
    if (root1 == null && root2 == null) return true;
    if (root1 == null || root2 == null) return false;
    if (root1.val != root2.val) return false;
    return helper(root1.left, root2.left) && helper(root1.right, root2.right);
}
```

