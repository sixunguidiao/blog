# 题目

给定一个字符串s和一个模式p，实现一个支持`.`和`*`的正则匹配。模式中的字符`.`表示任意一个字符，而`*`表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如字符串`"aaa"`与模式`"a.a"`和`"ab*ac*a"`匹配，但与`“aa.a”`和`"ab*a"`均不匹配。

# 思路1

《剑指offer》的解法。当没有`*`的时候，情况比较简单，我们只需要从左到右依次判断s和p的当前字符是否匹配即可。如果有`*`并且p中`*`前面的字符还和s的当前字符相同，我们分为三种情况去处理：匹配0个、匹配1个和匹配多个。

```java
public boolean isMatch(String s, String p) {
    if (s == null || p == null) return false; 
    return isMatchCore(s, p, 0, 0);
}

private boolean isMatchCore(String s, String p, int p1, int p2) {
    if (p2 == p.length() && p1 == s.length()) return true;
    if (p2 == p.length() && p1 != s.length()) return false;
    if (p2 < p.length() - 1 && p.charAt(p2 + 1) == '*') {
        if (p1 < s.length() && (s.charAt(p1) == p.charAt(p2) || p.charAt(p2) == '.')) {
            return isMatchCore(s, p, p1, p2 + 2) ||	// 匹配0个
                    isMatchCore(s, p, p1 + 1, p2 + 2) ||	// 匹配1个
                    isMatchCore(s, p, p1 + 1, p2);	// 匹配多个
        } else {
            return isMatchCore(s, p, p1, p2 + 2);   // 匹配0个
        }
    } else {
        if (p1 < s.length() && (s.charAt(p1) == p.charAt(p2) || p.charAt(p2) == '.')) {
            return isMatchCore(s, p, p1 + 1, p2 + 1);   // 匹配1个
        }
    }
    return false;
}
```

# 思路2

该方法对上述方法的逻辑做了简化。首先判断s和p的当前字符是否匹配，接着看p的下一个字符是不是`*`，如果不是`*`，继续判断s和p余下的字符；如果是`*`，或者匹配0个，即忽略p的当前字符和`*`，继续看p中余下的字符和s是否匹配；要么匹配多个，即从s中去掉1个字符，判断s中余下的字符和p是否匹配。和上一个思路把匹配分为匹配0个，匹配1个，匹配多个相比，这里把匹配1个和匹配多个在逻辑上统一成匹配多个了。

```java
public boolean isMatch(String s, String p) {
    if (p.isEmpty()) return s.isEmpty();
    boolean first_match = (!s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.'));	// 判断s的当前字符和p的当前字符是否匹配
    if (p.length() > 1 && p.charAt(1) == '*') {	// p的下一个字符是'*'
        return isMatch(s, p.substring(2)) ||	// 匹配0个
            (first_match && isMatch(s.substring(1), p));	// 匹配1个或多个
    } else {
        return first_match && isMatch(s.substring(1), p.substring(1)); // 匹配1个
    }
}
```

# 思路3

上述思路的dp版本。

```java
public boolean isMatch(String s, String p) {
    if (s == null || p == null) return false;
    boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];	// dp[i][j]表示s(i:)和p(j:)是否匹配
    dp[s.length()][p.length()] = true;	// 初始化dp，当s和p同时到达末尾时匹配成功
    for (int i = s.length(); i >= 0; i--) {	// 注意这里i是从s.length()开始，j是从p.length()-1开始，这是因为当s为空时也需要进行判断，比如s="",p="a*"，s和p也是匹配的
        for (int j = p.length - 1; j >= 0; j--) {
            boolean first_match = (i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.'));	// 判断s和p的当前字符是否匹配
            if (j < p.length() - 1 && p.charAt(j + 1) == '*') {	// 如果p的下一个字符是'*'
                dp[i][j] = (dp[i][j + 2] || (first_match && dp[i + 1][j]));	// 要么匹配个，要么匹配1个
            } else {	// 如果p的下一个字符不是'*'
                dp[i][j] = (first_match && dp[i + 1][j + 1]);	// 匹配1个
            }
        }
    }
    return dp[0][0];
}
```

