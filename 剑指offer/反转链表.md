# 题目

输入一个链表，反转链表后，输出新链表的表头。

# 思路1

递归。假设当前节点head的下一个节点next后面的部分已经反转完成了，考虑如何反转当前节点。我们需要把next的next指针指向当前节点，并且将head的next指针置为null。当head为null，返回null；当head的next指针为null，说明链表中只剩下一个节点，直接返回该节点即可。

```java
public ListNode reverseList(ListNode head) {
    // special
    if (head == null || head.next == null) return head;
    ListNode next = head.next;
    ListNode new_head = reverseList(next);
    next.next = head;
    head.next = null;
    return new_head;
}
```

# 思路2

循环。curr指示当前节点，prev指示当前节点的前一个节点，next指示当前节点的下一个节点。依次反转每个节点并向前移动指针。注意，反转时首先保存原链表中当前节点的下一个节点到next中，因为反转会修改curr的next指向。

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode curr = head;
    ListNode prev = null;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
```

