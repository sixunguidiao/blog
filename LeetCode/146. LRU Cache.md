# 题目

Design and implement a data structure for [Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU). It should support the following operations: `get` and `put`.

`get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
`put(key, value)` - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

**Follow up:**
Could you do both operations in **O(1)** time complexity?

**Example:**

```
LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```

# 题目大意

设计并实现一个适用于LRU cache的数据结构，支持 get(key) 和 put(key, value)，要求：

- get(key)：根据指定的 key 从 cache 中取得 value，如果不存在返回-1.

- put(key, value)：如果一个 key 存在于 cache 中，更新其 value；否则，插入一个 key 到 cache 中。如果 cache 达到 capacity 容量上限，在插入之前需要先将最近最不常使用的 key 删除。

- 要求 get() 和put() 的时间复杂度均为 O(1)。

# 思路

实现 LRU cache 的关键是使用一个 Map 和一个双端队列。Map 使我们可以在 O(1) 的时间内定位某个元素，双端队列使我们可以在 O(1) 的时间内删除最不常使用的元素。当我们访问完一个元素后，我们将其放到队列的头；当我们需要删除某个最近最不常使用的元素时，我们删除队列的最后一个元素。因此，队列的尾部保存的就是 cache  中最近最久未使用的元素。

在实现上，我们将每个元素包装成一个 Node，除了具有 key, val 属性外，还有两个指针 prev 和 next 分别指向前一个元素和后一个元素。类中有一个 Map 用来存放每个元素，Map 的 key 是元素的 key，Map 的 value 为 Node。还有一个用 head 和 tail 表示的双端队列，head 指示队列的头部，tail 指示队列的尾部。为了免去处理 null 节点的麻烦，我们将 head 和 tail 设计成两个 dummy 节点，即内部不存放任何元素 (key 和 value 均为-1)。调用 get() 时，如果 Map 中不包括该元素，直接返回-1；否则将该元素放到队列的头部并返回该元素的 value。调用 put() 时，如果 Map 中存在该元素，更新其 value 并将其放到队列的头部；否则，插入元素。在插入元素之前需要判断当前 Map 的大小是否达到容量上限 capacity，如果是，先删除位于队列尾部的元素并将其移出 Map，之后创建新元素加入 Map 并将其放到队列头部。

```java
class LRUCache {

    class Node {
        int key;
        int val;
        Node prev;
        Node next;

        public Node (int key, int val) {
            this.key = key;
            this.val = val;
        }
    }

    Map<Integer, Node> map = new HashMap<>();
    Node head = new Node(-1, -1);
    Node tail = new Node(-1, -1);
    int capacity = 0;

    public LRUCache(int capacity) {
        join(head, tail);
        this.capacity = capacity;
    }

    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        Node n = map.get(key);
        remove(n);
        moveToHead(n);
        return n.val;
    }

    public void put(int key, int value) {
        // if key exists in map, update it
        if (map.containsKey(key)) {
            Node n = map.get(key);
            n.val = value;
            remove(n);
            moveToHead(n);
        } else {    // otherwise, insert it into the map
            if (map.size() == capacity) {
                map.remove(tail.prev.key);
                remove(tail.prev);
            }
            Node n = new Node(key, value);
            map.put(key, n);
            moveToHead(n);
        }
    }

    private void remove (Node n) {
        n.prev.next = n.next;
        n.next.prev = n.prev;
    }

    private void moveToHead (Node n) {
        Node next = head.next;
        join(head, n);
        join(n, next);
    }

    private void join (Node n1, Node n2) {
        n1.next = n2;
        n2.prev = n1;
    }
}
```

