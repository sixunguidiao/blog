# 题目

Given a linked list, reverse the nodes of a linked list *k* at a time and return its modified list.

*k* is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of *k* then left-out nodes in the end should remain as it is.



**Example:**

Given this linked list: `1->2->3->4->5`

For *k* = 2, you should return: `2->1->4->3->5`

For *k* = 3, you should return: `3->2->1->4->5`

**Note:**

- Only constant extra memory is allowed.
- You may not alter the values in the list's nodes, only nodes itself may be changed.

# 题目大意

给定一个单链表，对每 k 个节点进行一次反转，返回修改后的链表的头节点。k 是一个正整数并且小于等于链表的长度，如果在反转的过程剩下的节点不够 k，则不进行反转。例如给定单链表：1->2->3->4->5，对于 k = 2，返回：2->1->4->3->5；对于 k = 3，返回：3->2->1->4->5。

注意：

1、要求时间复杂度为 O(1)。

2、不能改变链表中节点的值，只能改变节点的指向。

# 思路

我们可以用递归+迭代的思想去解决这个问题。拿 1->2->3->4->5，k = 2 这个例子来说，我们用 head 指示这个链表的头部，curr 指示第 k + 1 个节点，也就是3这个节点。我们假设 curr 之后的链表都已经正确地处理完毕了，即调用 curr = reverseKGroup(curr, k) 后 3->4->5 变成 4->3->5，并且返回4这个节点给 curr。此时 head 仍然指向1，而curr指向4。接下来我们需要做的工作是把 1->2->4->3->5 转换为 2->1->4->3->5，这个过程和我们在反转链表的迭代算法中的做法一样，curr 就是我们在反转链表迭代算法中的 prev，而 head 就是那里的 curr，我们对这 k 个节点依次进行反转，反转的链表的头结点就是 curr。

为了便于对比，下面我们先给出反转链表的迭代算法，然后给出本题的算法。

```java
// 反转链表
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode curr = head;
    ListNode prev = null;
    
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    
    return prev;
}

// 反转链表中的每个k个节点
public ListNode reverseKGroup(ListNode head, int k) {
	if (head == null || head.next == null) return head;
    ListNode curr = head;
    int count = 0;
    while (curr != null || count < k) {
        curr = curr.next;
        count++;
    }
    
    if (count == k) {
        curr = reverseKGroup(curr, k);
        while (count-- > 0) {
            ListNode next = head.next;
            head.next = curr;
            curr = head;
            head = next;
        }
        head = curr;
    }
    
    return head;
}
```

