# 堆排序

## 1. 堆

堆中某个节点的值总是大于等于其子节点的值 (大顶堆)，并且堆是一颗完全二叉树。

堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。**这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系**。

![img](https://cyc2018.github.io/CS-Notes/pics/8_200.png)

```java
public class Heap<T extends Comparable<T>> {

    private T[] heap;
    private int N = 0;

    public Heap(int maxN) {
        this.heap = (T[]) new Comparable[maxN + 1];
    }

    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }

    private boolean less(int i, int j) {
        return heap[i].compareTo(heap[j]) < 0;
    }

    private void swap(int i, int j) {
        T t = heap[i];
        heap[i] = heap[j];
        heap[j] = t;
    }
}
```

## 上浮和下沉

在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。

![img](https://cyc2018.github.io/CS-Notes/pics/81550405360028.gif)

```java
private void swim(int k) {
    while (k > 1 && less(k / 2, k)) {
        swap(k / 2, k);
        k = k / 2;
    }
}
```

类似地，当一个节点比子节点小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。**一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换**。

![img](https://cyc2018.github.io/CS-Notes/pics/91550405374894.gif)

```java
private void sink(int k) {
    while (2 * k <= N) {	// 叶节点不需要下沉
        int j = 2 * k;
        if (j < N && less(j, j + 1))
            j++;	// j是当前节点的两个子节点中最大的节点的下标
        if (!less(k, j))	// 当当前节点比两个子节点都大时，下沉结束
            break;
        swap(k, j);
        k = j;
    }
}
```

## 3. 插入元素

将新元素放到数组末尾，然后上浮到合适的位置。

```java
public void insert(Comparable v) {
    heap[++N] = v;
    swim(N);
}
```

## 4. 删除最大元素

从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。

```java
public T delMax() {
    T max = heap[1];
    swap(1, N--);
    heap[N + 1] = null;
    sink(1);
    return max;
}
```

## 5. 堆排序 (升序)

把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。

### 5.1 构建堆

无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。(如果选择从左到右遍历数组进行上浮操作，则需要遍历树中的每个节点，而如果选择从右到左进行下沉操作，也就是对树中每个非叶节点进行下沉操作，只需要遍历一半的元素，效率更高)

![img](https://cyc2018.github.io/CS-Notes/pics/101550406418006.gif)

### 5.2 交换堆顶元素和最后一个元素

交换之后需要进行下沉操作维持堆的有序状态。

![img](https://cyc2018.github.io/CS-Notes/pics/111550407277293.gif)

```java
public class HeapSort<T extends Comparable<T>> extends Sort<T> {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int k = N / 2; k >= 1; k--)
            sink(nums, k, N);

        while (N > 1) {
            swap(nums, 1, N--);
            sink(nums, 1, N);
        }
    }

    private void sink(T[] nums, int k, int N) {
        while (2 * k <= N) {
            int j = 2 * k;
            if (j < N && less(nums, j, j + 1))
                j++;
            if (!less(nums, k, j))
                break;
            swap(nums, k, j);
            k = j;
        }
    }
    
    private void swap(T[] nums, int i, int j) {
        T t = heap[i - 1];
        heap[i - 1] = heap[j - 1];
        heap[j - 1] = t;
    }

    private boolean less(T[] nums, int i, int j) {
        return nums[i - 1].compareTo(nums[j - 1]) < 0;
    }
}
```

## 6. 分析

一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。

对于堆排序，由于要对 N 个节点进行下沉操作，因此时间复杂度为 NlogN。**其中，建堆时间复杂度经推导为 O(N)**。

堆排序是一种原地排序，没有利用额外的空间。

现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。

