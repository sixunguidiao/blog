# 第一章 课程介绍及项目框架搭建

略。

# 第二章 实现登录功能

1. 数据库设计
2. 明文密码两次 MD5 处理
3. JSR303 参数检验 + 全局异常处理器
4. 分布式 Session (不是将 Session 存到单一的一个子系统中，而是将其存到 Redis 中，这样每个子系统都能够从 Redis 中获取用户的登录信息)

**问题1：为什么需要两次 MD5 处理？具体是如何实现的？**

为了进一步提高安全性。如果只做一次 MD5 的话，密码在网上传输时很容易被人抓包捕获作反查得到用户的真实密码。

实现：首先在客户端做第一次 MD5 处理，客户端先从表单获取密码，然后将密码和 salt1 (这个salt是在客户端写死的) 一起做一次 MD5，然后把处理后的密码发给服务端。服务端拿到这个处理后的密码，从用户表中取出 salt2 (这个 salt2 是在服务端随机生成的，生成后存到用户表中)，然后将第一次 MD5 处理后的密码和 salt2 再做一次 MD5，将这次处理的结果存到数据库中。

**问题2：为什么需要分布式 Session？具体是如何实现的？**

现在的系统一般都包括多个子系统，比如对于一个电商网站，用户可能在一个子系统上浏览商品，在另一个子系统上下单，各个子系统使用的容器可能是不同的。如果不使用分布式 Session，用户在某个子系统上浏览完商品准备下单时，跳到另一个子系统，而此时另一个子系统并没有保存这个用户的 Session，需要用户重新做一遍登录，给用户带来了麻烦。

实现：实现上主要是通过 Cookie + redis 来实现。首先用户登录某个子系统时，在服务端生成一个 token (个人认为这个 token 就是一个 Session ID)，这个 token 用来标识这个用户，将这个 token 作为键，用户对象作为值存到 redis 中，然后为这个 token 生成一个 Cookie (Cookie name 无所谓，比如就叫"token") 并将其添加到 response (响应正文) 中。当用户又访问另一个子系统时，浏览器会将这个 Cookie 发送过来，服务端通过解析这个 Cookie 得到 token，利用 token 从 redis 中取出这个用户即可。

**问题3：为什么在 login() 方法中加入 cookie 后，用户登录成功并跳转到 goos_lists 页面时 request 中会自动带上 cookie？**

答：我的一种猜测是服务器将 cookie 传给浏览器，浏览器将 cookie 保存到浏览器缓存中，然后下次请求时直接从缓存中取出 cookie 发给服务器。

# 第三章 秒杀功能开发及管理后台

## 数据库设计

- 商品表 (id、名称、标题、图片、详情、价格 (原价)、库存)
- 秒杀商品表 (id、商品 id、秒杀价格、库存 (秒杀的)、**开始时间**、**结束时间**)
- 订单表 (用户 id、商品 id、收货地址 id、商品名称、商品数量 (下单的)、下单价格、订单渠道、订单状态、下单时间、支付时间)
- 秒杀订单表 (用户 id、商品 id)
- 用户表 ()

**问题1：为什么要单独创建一个秒杀商品表而不是直接在商品表中添加一个字段标识某个商品是不是秒杀商品呢？**

答：当促销活动多了，原商品表会变得越来越难以维护，需要经常修改，导致原来的老代码也要跟着修改。

**问题2：为什么倒计时的功能要放到客户端做而不是服务端做？**

答：因为放到服务端做的话给服务器的压力太大了，每秒客户端都要请求一次服务器获取倒计时时间。但也正是因为放到客户端做会导致客户端的计时和服务端的计时不同步，所以秒杀也是看运气的。

# 第4章-秒杀压测-Jmeter压力测试

1. JMeter 入门
2. 自定义变量模拟多用户
3. JMeter 命令行使用
4. redis 压测工具 redis-benchmark

5. Spring Boot 打 war 包

 系统并发性能的瓶颈在**数据库**。

**问题**：作者说秒杀的时候秒杀的接口"/do_miaosha"一定要是 PUT 的而不能是 GET，为什么？

# 第5章-页面级高并发秒杀优化（Redis 缓存 + 静态化分离）

1. 页面缓存 (最大粒度) + URL 缓存 + 对象缓存 (最小粒度)

2. 页面静态化，前后端分离

3.  静态资源优化

4. CDN 优化

## 页面缓存

1. 从缓存 (redis) 中取 html
2. 手动渲染模板
3. 渲染成功后将 html 保存到缓存中

页面缓存的有效期一般都比较短。适合变化不大的页面。 

如缓存商品详情页面 "goods_list"。

 ## URL 缓存

其实和页面缓存一样，只不过这里缓存的页面是有业务参数的。比如"goods_detail"页面，不同商品的详情页面是不同的。

## 对象缓存

做对象缓存时要注意，如果对象状态发生了更新 (例如某个用户修改了密码)，要记得更新之前的缓存。使用对象缓存时要注意：

- 失效：应用程序先从 cache 中取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
- 命中：应用程序从 cache 中取数据，取到后返回。
- 更新：先把数据存到数据库中，成功后，再让缓存失效。

## 页面静态化

1. 常用技术 AngularJS，Vue.js

2. 优点：利用浏览器缓存。

页面静态化是指页面存一个 html，动态数据利用接口进行获取，服务端只要写接口就行了。比如对于商品详情这个页面，动态数据指的就是商品 ID，商品名称，商品价格等，而其他的比如页面的 logo 等就没有必要请求服务器了。

页面静态化其实就是 Html + Ajax，原来客户端向服务端请求访问一个页面，服务端将这个页面渲染好了之后发给客户端，现在服务端只提供这个页面的动态数据，客户端利用 Ajax 从服务端获取动态数据后自己渲染页面 (使用 JS)，再加上浏览器本身也会对页面做缓存，因此减小了服务器的负载。

 ## 秒杀静态化

GET 和 POST 的区别：

GET  是**幂等**的，意思就是 GET 不会对服务器上的数据做修改，POST 不是幂等的，POST 可能会对服务器上的数据发生修改。例如"/delete?id=1"这种可能会引发非常严重的错误，因为可能搜索引擎在遍历到你这个 url 的时候不知不觉就把你服务器上的数据删掉了。

## 订单详情静态化

假如一个用户同时发出两个秒杀的请求，这两个请求先判断库存是否为空，不为空，接着判断是否已经秒杀到了，没有秒杀到，然后进入到秒杀的环节，即减库存，下订单，那么一个用户就秒杀到两个商品了。这种情况应该怎么办呢？

**这就是我们在数据库中为什么要建一个秒杀订单表的原因**。秒杀订单表中有一个 user_id 和 goods_id，我们在秒杀订单表中给 user_id 建一个唯一性的索引即可解决这个问题。当第一个请求秒杀成功并且数据插入到数据库后，第二请求过来又执行插入 (这里我们利用了数据库的锁，两个请求也就是两个事务是同步执行的)，此时发现数据库表中带有这个 user_id 的记录已经存在了，插入失败，数据库进行回滚。

实际上用户在进行秒杀之前会需要输入验证码，不会让用户同时发出两个请求的。但是为了以防万一，这里还是做了一下。

**如何解决卖超的问题**

卖超问题的产生是由于：当库存为1的时候，两个请求同时进入到秒杀环节，同时进行减库存的操作，由于我们之前在减库存中是直接在数据库中做"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #{goodsId}"，即将该商品的库存减1，当库存为1时，第一个请求更新数据库把库存减为0，第二个请求更新数据库把库存减为-1，造成了卖超的问题。

解决这个问题可以把更新语句改为"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #{goodsId} and stock_count > 0"，即在减库存时先判断当前库存是不是大于0，如果大于0，则将库存减1，否则什么也不做。由于在数据库中每个请求都会正确地进行加锁、解锁，因此这样做可以解决卖超的问题。

总结：

数据库加唯一索引：防止用户重复购买

SQL 加库存数量判断：防止库存变负数

## 静态资源优化

1. JS/CSS 压缩，减少流量 (如 jQuery.min.js)
2. 多个 JS/CSS 组合，减少连接数 (通过一个请求将 JS/CSS 全部搞下来)
3. CDN就近访问。实际上用的也是一种缓存的思想，将网站的数据在每一个节点上都做一个缓存，用户请求会被映射到最近的节点上去取资源。

**可以加缓存的地方**

通过做页面静态化可以直接把页面缓存到用户的浏览器

部署 CDN 节点让请求到达网站之前可以先访问 CDN

Nginx 也可以加缓存 (Nginx 作为代理服务器)

应用程序页面缓存

对象缓存

数据库

# 第6章-服务级高并发秒杀优化（RabbitMQ + 接口优化）

1. redis 预减库存减少对数据库的访问
2. 内存标记减少对 redis 的访问
3. 请求先入队，异步下单，增强用户体验

4. RabbitMQ 安装与 Spring boot 集成
5. Nginx 水平扩展

如果要做分库分表，可以用 mycat。

**思路：减少对数据库访问。**

1. 系统初始化时，把商品库存数量加载到 redis 中
2. 收到请求，redis 预减库存，库存不足，直接返回，否则进入3
3. 请求入队，立即返回排队中
4. 请求出队，减少库存，生成订单 (事务)
5. 客户端轮询 (订单)，是否秒杀成功

## MQ

四种交换机模式。交换机的意思是发送者在把消息往外发送的时候，并不是直接放到队列中，而是先发送到交换机上，然后由交换机把消息发送到队列中。这样做的好处是可以做一个路由。

1. Direct 模式：

最简单的模式是 Direct 模式，发送者指定一个队列名，指定一个消息，将消息放到队列中，接收者监听一个队列名，获得消息。

2. Topic 模式

可以将消息发送给多个 queue，带通配符，通过给每个 queue 绑定不同的 exchange (交换机) 将消息路由到不同的 queue中。

3. Fanout 模式

也即广播模式，可以将消息发给多个 queue，没有 exchange 的限制。

4. Header 模式

在绑定的时候可以指定一个 Map 类型的 header 头部信息，可以选择是匹配 header 中的全部信息还是 header 中的部分信息。假设我们匹配 header 中的全部信息。发送者在发送时可以往消息中添加 header，由于我们在绑定时指定匹配所有 header，因此只有当发送者发送的消息的中的 header 和绑定时建立的 header 匹配时，消息才能发送成功。 

使用交换机模式时需要建立一个队列，建立一个交换机，然后建立一个绑定，将队列绑定到交换机上。这里"建立"的意思是在容器中注册一个 bean。

## 秒杀接口优化

思路：把同步下单改为异步下单。

在秒杀接口中通过 redis 先判断是否还有库存，如果没有库存直接返回"秒杀失败"，否则，继续判断该用户是否已经秒杀到了 (这里是通过在 redis 中查看是否已经生成了这个用户的秒杀订单实现的)，如果已经秒杀到了，返回"不能重复秒杀"，否则，将秒杀请求入队，此时接口直接向客户端返回"排队中"。

在服务端的消息接收者这边继续处理秒杀的过程。先判断是否还有库存 (此时访问的是数据库，由于能够到达这里的请求已经很少了，因此不会对数据库性能造成太大的影响)，如果没有库存，结束，如果有库存，判断是否已经秒杀到了 (同接口中的判断逻辑一样，通过 redis 查看是否已经了生成这个用户的秒杀订单)，如果已经秒杀到了，结束，否则，减库存并下订单。

在减库存并下订单的过程中，首先判断减库存是否成功，如果减库存成功，则下订单。如果减库存失败，则在 redis 中设置一个标记，表示该商品已经被秒杀完了 (这是为了后面客户端轮询的时候用)。

在客户端进行轮询的时候，实际上是用 Ajax 不断去调用服务端的查询接口查询秒杀的结果。查询时，服务端先去 redis 中查这个用户的秒杀订单是否已经生成，如果生成了，返回"秒杀成功"，否则，服务端就去 redis 中查上面说的那个标记，如果标记在 redis 中被设置了，说明该商品已经被秒杀完了，返回 "秒杀失败"，否则，返回"排队中"，在这种情况下客户端继续对秒杀结果进行轮询。

在预减库存时，先在 redis 中将库存减1，然后判断库存是否小于0，如果小于0，说明商品已经被秒完了，直接返回。但是这里还可以做一个优化，当商品已经被秒杀完的时候，后面的请求再进来，还是会访问 redis，虽然 redis 很快，但是一直访问 redis 也会对 redis 的性能造成影响。其实我们这里可以做一个内存标记来减少后面的请求对 redis 的访问。比如创建一个 map，map 的 key 是商品 id，map 的 value 是一个布尔类型的标记，true 表示该商品已经被秒杀完了。在预减库存时，当某个商品第一次被减到小于0时，我们在 map 中将这个商品的 value 置为 true，当后面的请求过来时，我们先访问这个 map 判断该商品是否已经秒杀完，如果秒杀完直接返回，这样一来就减少了对 redis 的访问。

# 安全优化

1. 秒杀接口地址隐藏 (秒杀之前是拿不到秒杀地址的，访问 path 接口时会检查商品是否在秒杀时间内，如果不是，返回一个错误信息)
2. 数学公式验证码 (1. 防止机器人恶意刷；2.用户在输入验证码的时候会消耗一定的时间，在一定程序上削减了并发量)

3. 接口限流防刷 (比如1分钟之内限制一个用户只能刷100次)

前端的一些合法性验证只能起到防止用户输错的作用，不能防止非法用户，也就是“防君子不防小人”，因为前端的代码都是透明的，别人可以直接从你的前端代码中拿到你的秒杀地址然后直接访问。所以安全要在服务端实现。

## 秒杀接口地址隐藏

思路：秒杀前，先去请求接口获取秒杀地址

1. 接口改造，带上 PathVariable 参数
2. 添加生成地址的接口
3. 秒杀收到请求，先验证 PathVariable

## 数学公式验证码

思路：点击秒杀之前，先输入验证码，分散用户的请求

1. 添加生成验证码的接口
2. 在获取秒杀路径的时候，验证验证码
3. ScriptEngine 使用 (JDK 1.6新加的)

过程是：在秒杀前需要先获取秒杀地址，秒杀地址中带有一个 path 参数，该 path 在服务端用 uuid 生成，需要先请求服务端的 "path" 接口来获取这个 path。客户端在获取了这个 path 之后利用这个 path 调用真正的秒杀接口来进行秒杀。

在获取 path 的时候，需要用户输入验证码。验证码在用户第一次访问这个页面的时候会调用生成验证码的接口生成一个验证码，服务端将这个验证码存到 redis 中。但是验证码是有有效时间的，如果用户在这个页面停留的时间过长，那么服务端 redis 上这个验证码会失效。当用户点击验证码图片的时候会调用生成验证码的接口重新生成一个验证码。

当用户输入正确的验证码后点击秒杀，服务端会生成一个 path，并把该 path 保存到 redis 中，然后向客户端返回这个 path，客户端拿到这个 path 后将 path 加到请求地址中再去调用秒杀接口进行秒杀，服务端在秒杀接口中先对 path 进行验证，如果验证通过了再继续执行后面的操作。这样一来就实现了对秒杀接口地址的隐藏 (其实就是在秒杀地址中插入一个 path)。

**备注**：其实我觉得更安全的做法是通过跳转进行判断，访问秒杀接口之前判断请求是不是从正确的页面发过来的，从根本上杜绝用户直接从浏览器地址栏输秒杀地址提前进行秒杀。

## 接口防刷

思路：对接口做限流

假如现在需要限制一个接口在5s内只能访问5次。**我们约定从用户第一次访问这个接口开始计时**。其实用 redis 实现很简单，在 redis 中我们把这个用户对这个接口的请求保存为 key，这个用户在5s内对这个接口的访问次数保存为 value。当这个用户第一次访问这个接口时，在 redis 中建立一个这个样的键值对，**设置这个键值对的有效时间为5s**，初始时 value 为1。此后这个用户在访问这个接口时，从 redis 中取出这个键值对，如果 value 的值小于5，value++，否则，说明这个用户在5s内访问这个接口的次数超过了5次，返回错误信息"请求太频繁"。这样一来相当于我们利用 redis 中每个键值对有一个有效时间这个功能实现了对接口的限流。

一个引申的问题：

如何检测同一个 IP 在一分钟之内请求超过1000次，如果是的话，把它毙掉。

思路1：Queue

为每个 IP 建立一个队列，队列的容量为1000，当一个 IP 进来了，将该 IP 插入到队列中。如果队列没有满，我们是将 IP 插入到队列的队尾；如果队列已经满了，则我们需要从队列的队头删除 IP。在删除的时候，我们看队头的 IP 的请求时间和当前需要插入到队列的 IP 的请求时间之差是不是小于1分钟，如果是，说明这个请求在1分钟之内的请求次数超过了1000，把它毙掉。而且每隔一分钟还要清空一次队列。

这样做需要在服务端为每个 IP 维护一个队列，当 IP 很多的时候，空间开销太大。

思路2：Map + 时间戳

维护一个 Map，Map 的 key 是每个 IP，value 存储这个 IP 的一个时间戳和一个count，当一个 IP 第一次请求时，这个 IP 的时间戳是第一次请求的时间，count为1。此后每进来一个 IP，将该 IP 的 count++ 并且将该 IP 的当前请求时间和 Map 中的时间戳进行比较，看它们的差是不是一分钟，如果是并且 count 大于1000，说明该 IP 在1分钟之内请求超过1000次，把它毙掉，否则，说明该 IP 是一个正常的 IP，重置该 IP 的时间戳为当前请求时间，并且将该 count 重置为1。

## 如何做一个通用的接口来处理限流

可以用拦截器减少对业务的侵入。

之前如果要对某个接口做拦截，需要将拦截代码写在接口中，和接口的业务代码耦合在一起，而且如果要改变拦截的方式，比如之前我是限制某个接口5s内只能访问5次，现在我想5s内访问10次，那么还要去到该接口中改代码。这样做显然是很麻烦的。

如果我们需要对某个接口做限流，可以在该接口上加一个注解`@AccessLimit(seconds = 5, maxCount = 5, needLogin = true)`，其中`seconds = 5·, maxCount = 5`限制该接口5s内只能访问5次。在实现上，我们需要先创建一个这样的注解类，然后创建一个**拦截器**，在拦截器中设置对方法的拦截，如果某个方法上有 @AccessLimit 注解，读出 seconds, maxCount, needLogin 的值，然后在拦截逻辑中根据这些参数的值在 redis 中创建不同的 key，最后在 Spring Boot 中注册这个拦截器就行了。这样一来就可以灵活地配置每个接口的限流策略了。

在拦截器中还可以做的一件事情就是获取用户。之前我们是将获取用户的逻辑写到 UserArgumentResolver 这个类，然后在 Controller 中使用这个 User 对象，现在我们可以把这个事情放到拦截器中去做。在拦截器中我们获取到 User 之后可以将 User 存到一个 ThreadLocal 中，由于一个请求对应一个线程，而 ThreadLocal 是线程封闭的，因此我们就可以在程序的各个地方通过这个 ThreadLocal 来使用这个 User 对象了。

# 课程总结及重难点回顾

## 如何解决少卖问题——Redis 预减成功而 DB 减库存失败

前面的方案中会出现一个少卖的问题。Redis 在预减库存的时候，在初始化的时候就放置库存的大小，redis 的原子减操作保证了多少库存就会减多少，也就会在消息队列中放多少。

现在考虑两种情况：

1. 数据库那边出现非库存原因比如网络等造成减库存失败，而这时 redis 已经减了。

2. 万一一个用户发出多个请求，而且这些请求恰巧比别的请求更早到达服务器，如果库存足够，redis 就会减多次，redis 提前进入卖空状态，并拒绝。不过这两种情况出现的概率都是非常低的。

两种情况都会出现少卖的问题，实际上也是**缓存和数据库出现不一致的问题**！

但是我们不是非得解决不一致的问题，本身使用缓存就难以保证强一致性：

**在 redis 中设置库存比真实库存多一些就行**。