# 题目

一个链表中包含环，找到环的入口节点。

# 思路1

从头开始遍历链表，用一个 set 保存已经走过的节点。当当前节点已经存在于 set 中时，说明链表中有环并且当前节点就是环的入口节点。

代码略。

# 思路2：

我们先来分析这样一个问题：如何判断一个链表中是否存在环？我们可以让一个快指针 fast 和一个慢指针 slow 同时从链表的第一个节点开始向前走，fast 每次走2步，slow 每次走1步。如果两个指针相遇则说明链表中存在环，如果 fast 走到链表的末尾两个指针还没有相遇则说明链表中不存在环。现在我们再设置一个指针 p 从链表的第一个节点开始向前走，每次走1步，slow 从相遇的地方继续向前走，每次也走1步，当 p 和 slow 相遇时，相遇节点就是环的入口节点。

证明：设 entry 为环的入口节点。当 slow 和 fast 相遇时，设 slow 走过的路程为 A + B，其中 A 为 head 到 entry的路程，B 为 slow 在环中走过的路程，N 为环的长度。由于相遇时 fast 比 slow 多走了一圈，因此 fast 走过的路程为 A + B + N (1)，同时由于 slow 每次走1步，fast 每次走2步，所以 fast 走过的路程又可以表示为 2A + 2B (2)。联立 (1) 和 (2) 得 A + B = N，所以相遇节点到 entry 的距离和 head 到 entry 的距离是相同的。

```java
private ListNode entryNodeOfLoop(ListNode head) {
    if (head == null || head.next == null) return null;
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) break;
    }
    if (fast == null || fast.next == null) return null;    // 链表中没有环
    ListNode p = head;
    while (p != slow) {
        p = p.next;
        slow = slow.next;
    }
    return p;
}
```

# 思路3

书上的方法。定义两个指针，设环中有 n 个节点，先让第一个指针从链表头开始在链表上走 n 个单位，然后两个指针再一起走，每次走一个单位。当两个指针相遇时，相遇节点就是环的入口节点。关键是如何求出环中的节点个数。借由上一题的分析，我们可以让 slow 从相遇节点处继续向前走，并记录走过的节点个数，当再次回到这个节点时，即可得出环中的节点个数。

```java
public ListNode entryNodeOfLoop(ListNode head) {
   if (head == null || head.next == null) return null;
   ListNode meetingNode = findMeetingNode(head);
   if (meetingNode == null) return null;
   ListNode curr = meetingNode;
   int nodesInLoop = 1;  // 环中的节点个数
   while (curr.next != meetingNode) {
       curr = curr.next;
       nodesInLoop++;
   }
   ListNode fast = head;
   for (int i = 0;i < nodesInLoop; i++) {
       fast = fast.next;
   }
   ListNode slow = head;
   while (slow != fast) {
       slow = slow.next;
       fast = fast.next;
   }
   return slow;
}

// 如果链表中存在环，返回slow和fast相遇的节点；如果链表中不存在环，返回null
private ListNode findMeetingNode(ListNode head) {
   if (head == null || head.next == null) return null;
   ListNode slow = head;
   ListNode fast = head;
   while (fast != null && fast.next != null) {
       slow = slow.next;
       fast = fast.next.next;
       if (slow == fast) return slow;
   }
   return null;
}
```

