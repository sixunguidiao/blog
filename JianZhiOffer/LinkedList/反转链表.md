# 题目

输入一个链表，反转链表后，输出新链表的表头。

# 思路1

递归。假设当前节点 head 的下一个节点 next 后面的部分已经反转完成了，考虑如何反转当前节点。我们需要把next 的 next 指针指向当前节点，并且将 head 的 next 指针置为 null。当 head 为 null，返回 null；当 head 的next 指针为 null，说明链表中只剩下一个节点，直接返回该节点即可。

```java
public ListNode reverseList(ListNode head) {
    // special
    if (head == null || head.next == null) return head;
    ListNode next = head.next;
    ListNode new_head = reverseList(next);
    next.next = head;
    head.next = null;
    return new_head;
}
```

# 思路2

循环。curr 指示当前节点，prev 指示当前节点的前一个节点，next 指示当前节点的下一个节点。依次反转每个节点并向前移动指针。注意，反转时首先保存原链表中当前节点的下一个节点到 next 中，因为反转会修改 curr 的next 指向。

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode curr = head;
    ListNode prev = null;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
```

