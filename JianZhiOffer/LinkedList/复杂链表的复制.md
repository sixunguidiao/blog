# 题目

输入一个复杂链表（每个节点中有节点值以及两个指针，一个指针 next 指向下一个节点，另一个指针 random 指向链表中任意一个节点），返回结果为复制后的复杂链表的头结点。

# 思路1

map。将复杂链表的复制分为两步，第一步，复制原链表的每个节点，并用 next 链接起来，同时将原节点和复制节点存到 map 中（原节点作为 key，复制节点作为 value）；第二步，设置复制链表中每个节点的 random 指针。遍历原链表，如果节点 N 的 random 为 S，则通过 map 可以在 O(1) 时间内找到 N1 和 S1，设置 N1.random = S1 即可。

```java
class RandomListNode {
    int label;
    RandomListNode next;
    RandomListNode random;

    RandomListNode (int label) {
        this.label = label;
    }
}

public RandomListNode clone (RandomListNode pHead) {
    if (pHead == null) return null;
    Map<RandomListNode, RandomListNode> map = new HashMap<>();
    //复制原链表的每个节点，并用next链接起来
    RandomListNode curr = pHead;	// 原链表的当前节点
    RandomListNode clonedHead = null;	// 复制链表的头结点
    RandomListNode clonedCurr = null;	// 复制链表的当前节点
    while (curr != null) {
        RandomListNode clonedNode = new RandomListNode(curr.label);
        map.put(curr, clonedNode);
        if (clonedHead == null) {
            clonedHead = clonedCurr = clonedNode;
        } else {
            clonedCurr.next = clonedNode;
            clonedCurr = clonedCurr.next;
        }
        curr = curr.next;
    }
    //设置复制链表的random
    curr = pHead;
    while (curr != null) {
        if (curr.random != null) {
            RandomListNode currCloned=null;
            RandomListNode randomCloned=null;
            if (map.containsKey(curr)) currCloned = map.get(curr);
            if (map.containsKey(curr.random)) randomCloned = map.get(curr.random);
            if (currCloned != null) currCloned.random = randomCloned;
        }
        curr = curr.next;
    }
    return clonedHead;
}
```

时间复杂度：O(N)。

空间复杂度：O(N)。

# 思路2

同样是用空间换时间的思想，但是不同于上一个思路中用额外的存储空间存储节点和节点的 random 之间的映射关系，这次我们直接在原链表上完成复制。

我们将复杂链表的复制过程分为三个步骤：

1. 复制链表中的每个节点并将复制的节点直接链接到原节点的后面，此时不设置每个节点的 random。

2. 设置复制节点的 random。若 N 的 random 是 S，则 N1 的 random 就是 S 的下一个节点 S1。
3. 此时该链表中奇数位置的节点构成原链表，偶数位置的节点构成复制链表，将其拆分出来即可。 

```java
public RandomListNode clone (RandomListNode pHead) {
   if (pHead == null) return null;
   cloneNodes(pHead);
   connectNodes(pHead);
   return reConnectNodes(pHead);
}

// 复制链表中每个节点，将复制节点直接链接到原节点的后面
private void cloneNodes (RandomListNode head) {
   RandomListNode curr = head;
   while (curr != null) {
       RandomListNode clonedNode = new RandomListNode(curr.label);
       clonedNode.next = curr.next;
       clonedNode.random = null;
       curr.next = clonedNode;
       curr = clonedNode.next;
   }
}

// 设置复制节点的random
private void connectNodes (RandomListNode head) {
   RandomListNode curr = head;
   while (curr != null) {
       RandomListNode clonedNode = curr.next;
       if (curr.random != null) {
           clonedNode.random = curr.random.next;
       }
       curr = clonedNode.next;
   }
}

// 将复制后的链表拆分成原链表和复制链表并返回复制链表的头结点
private RandomListNode reConnectNodes (RandomListNode head) {
   RandomListNode curr = head;
   RandomListNode clonedHead = null;
   RandomListNode clonedCurr = null;
   // 设置clonedHead
   if (curr != null) {
       clonedHead = clonedCurr = curr.next;
       curr.next = clonedCurr.next;
       curr = curr.next;
   }
   while (curr != null) {
       clonedCurr.next = curr.next;
       clonedCurr = clonedCurr.next;
       curr.next = clonedCurr.next;
       curr = curr.next;
   }
   return clonedHead;
}
```

时间复杂度：O(N)。

空间复杂度：O(1)。

