# 题目

输入两个链表，找出它们的第一个公共节点。

# 思路1

先求出长链表的长度 len1，短链表的长度 len2，两个链表的长度差 diff。之后，先在长链表上走 diff 步，然后两个链表再一起走，直到或者两个链表中有一个为 null (没有公共结点) 或者找到第一个公共节点。

```java
public ListNode findFirstCommonNode (ListNode head1, ListNode head2) {
    if (head1 == null || head2 == null) return null;
    int len1 = getLength(head1);
    int len2 = getLength(head2);
    ListNode curr_long = head1;
    ListNode curr_short = head2;
    int diff = Math.abs(len1 - len2);
    if (len2 > len1) {
        curr_long = head2;
        curr_short = head1;
    }

    // 先在长链表上走diff步
    for (int i = 0; i < diff; i++) {
        curr_long = curr_long.next;
    }

    // 两个链表再一起走
    while ((curr_long != null) && (curr_short != null)) {
        curr_long = curr_long.next;
        curr_short = curr_short.next;
        if (curr_long == curr_short) break;
    }

    return curr_long;
}

private int getLength(ListNode head) {
    int len = 0;
    ListNode curr = head;
    while (curr != null) {
        len++;
        curr = curr.next;
    }
    return len;
}
```

# 思路2

“两次迭代”法，即通过两次迭代即可找出两个链表的第一个公共节点。用两个指针分别指示两条链表，第一次迭代时如果第一条链表的指针到达第一条链表的末尾时，将其置为第二条链表的头结点；如果第二条链表的指针到达第二条链表的末尾时，将其置为第一条链表的头结点。这样经过一轮迭代后就消除了两个链表之间的长度差，之后两个指针每次向前前进一个节点，最终到达两个链表的第一个公共节点。采用这种方法免去了分别计算两个链表长度的麻烦。

```java
public ListNode findFirstCommonNode (ListNode head1, ListNode head2) {
    if (head1 == null || head2 == null) return null;
    ListNode curr1 = head1;
    ListNode curr2 = head2;
    while (curr1 != curr2) {
        curr1 = curr1 == null ? head2 : curr1.next;
        curr2 = curr2 == null ? head1 : curr2.next;
    }
    return curr1; // or return curr2;
}
```

