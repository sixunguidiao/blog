# 题目

统计数字k在排序数组中出现的次数。例如输入数组[1, 2, 3, 3, 3, 3, 4, 5]，k = 3，输出4。

# 思路

当然，我们可以顺序遍历数组来统计k在数组中出现的次数，也可以先用二分查找找到一个k，由于k的左边和右边也有可能有k，我们从当前位置出发分别沿左，右两个方向顺序地寻找k。因为要查找的数字在长度为n的数组中有可能出现n次，所以上面两种方法的时间复杂度都是O(N)。我们来看看有没有更好的方法。

当我们用二分查找在数组中找到一个k时，如果前面没有k了，那么这个k就是k第一次出现的位置；如果前面还有k，我们继续在前半部分中用二分查找寻找k第一次出现的位置；同理，我们可以得到k最后一次出现的位置。找到了k第一次出现的位置和最后一次出现的位置，我们就可以算出k在数组中的出现次数了。

```java
public int getNumberOfK(int[] nums, int k) {
    if (nums == null || nums.length == 0) return 0;
    int first = getFirstK(nums, k);	// k第一次出现的位置
    int last = getLastK(nums, k);	// k最后一次出现的位置
    if (first > -1 && last > -1) {
        return last - first + 1;
    }
    return 0;
}

// 返回k在数组中第一次出现的位置
private int getFirstK(int[] nums, int k) {
    int lo = 0;
    int hi = nums.length - 1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        if (nums[mid] == k) {
            if (mid == 0 || nums[mid - 1] != k) {	// 如果当前k是第一个k
                return mid;
            } else {	// 否则，继续在数组的前半部分找第一个k
                hi = mid - 1;
            }
        } else if (nums[mid] < k) {
            lo = mid + 1;
        } else {
            hi = mid - 1;
        }
    }

    return -1;	// 如果当前数组中没有k，返回-1
}

// 返回k在数组中最后一次出现的位置
private int getLastK(int[] nums, int k) {
    int lo = 0;
    int hi = nums.length - 1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        if (nums[mid] == k) {
            if (mid == nums.length - 1 || nums[mid + 1] != k) {	// 如果当前k是最后一个k
                return mid;
            } else {	// 否则，继续在数组的后半部分找最后一个k
                lo = mid + 1;
            }
        } else if (nums[mid] < k) {
            lo = mid + 1;
        } else {
            hi = mid - 1;
        }
    }

    return -1;	// 如果当前数组中没有k，返回-1
}
```

