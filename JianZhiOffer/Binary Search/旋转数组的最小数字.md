# 题目

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

# 思路1

遍历数组，找到第一个当前数字比前一个数字小的数字，该数字就是数组中最小的数字。

时间复杂度：O(N)

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] < nums[i - 1]) {
            return nums[i];
        }
    }
    return nums[0];	// 如果不存在这样的数字，说明数组已经是排好序的，第一个数字是最小的数字
}
```

# 思路2

旋转之后的数组可以看做是由两个递增的子数组所构成，而这个最小的数就是这两个子数组的分界点。可以借助二分查找的思想去寻找这个最小的数。初始时用lo指示数组的第一个数，hi指示数组的最后一个数，mid指示lo和hi中间的数。如果array[mid] >= array[lo]，说明最小的数在mid和hi之间，移动lo到mid在后半数组中继续查找；如果array[mid] < array[lo]，说明最小的数在前半数组中，移动hi到mid在前半数组中继续查找。当hi - lo == 1时，hi指示的就是数组中最小的数。注意，当lo，mid，hi三个指针指示的数相同时，无法判断最小的数在前半数组中还是在后半数组中，这时需要顺序查找。

时间复杂度：O(logN)

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int lo = 0;
    int hi = nums.length - 1;
    while (nums[lo] >= nums[hi]) {	// 在我们的循环不变式中，lo指向前一个递增子数组，hi指向后一个递增子数组，因此这里循环条件是nums[lo] >= nums[hi]
        if (hi - lo == 1) {
            return nums[hi];
        }
        int mid = lo + (hi - lo) / 2;
        // 当lo, hi, mid指向的数字相同时，此时无法判断mid指向的数字属于前一个子数组还是后一个子数组，此时需要用顺序遍历找到nums[lo, ..., hi]中的最小数字
        if (nums[lo] == nums[mid] && nums[mid] == nums[hi]) {
            return helper(nums, lo, hi);
        }
        if (nums[mid] >= nums[lo]) {
            lo = mid;
        } else {
            hi = mid;
        }
    }
    return nums[0];	// 如果数组本身已经是排好序的，第一个数字是最小的数字
}

private int helper(int[] nums, int lo, int hi) {
    int min = nums[lo];
    for (int i = lo + 1; i <= hi; i++) {
        min = Math.min(min, nums[i]);
    }
    return min;
}
```

