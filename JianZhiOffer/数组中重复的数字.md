# 题目
在一个长度为n的数组中，所有的数字都在0-n的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。找出数组中任意一个重复的数字。例如如果输入长度为7的数[2,3,1,0,2,5,3]，那么对应的输出是重复的数字2或3。

# 思路

可以先对数组进行排序，然后从头到尾遍历数组找到重复的数字，时间复杂度为O(NlogN)。也可以用一个set保存已经扫描过的数字，如果当前数字已经包含在了set里，那么就找到了一个重复的数字，时间复杂度为O(N)，空间复杂度为O(N)。接下来我们看看能不能把空间复杂度优化为O(1)。注意到题目中说所有数字的范围都在0-n，因此我们可以根据下标来重排这个数组。从头到尾扫描这个数组，当扫描到下标为i的数字时，首先比较这个数字（用m表示）是不是等于i，如果是，说明m已经被放在了正确的位置上，接着扫描下一个数字。如果不是，拿它和下标为m的数字进行比较，如果它和下标为m的数字相等，我们就找到了一个重复的数字（该数字在下标为i和m的位置都出现了）。如果它和下标为m的数字不等，就把第i个数字和第m个数字进行交换，把m放到它正确的位置上去。接下来重复这个过程，直到我们找到了一个重复的数字，返回true，否则，数组中没有重复数字并且算法结束后所有的数字都放置了它正确的位置上个，返回false。备注：代码中尽管有一个两重循环，但是对于每个数字最多只需要进行一次交换和一次遍历就能找到其正确的位置，因此总的时间复杂度是O(N)。

```java
public int findDuplicatedNumber(int[] nums) {
    if (nums == null || nums.length == 0) return -1;

    for (int i = 0;i < nums.length;i ++) {
        while (i != nums[i]) {
            if (nums[i] == nums[nums[i]]) return nums[i];
            swap(nums, nums[i], nums[nums[i]]);
        }
    }

    return -1;  // 如果数组中没有重复的数字返回-1
}

private void swap (int[] nums, int i, int j) {
    if (i != j) {
        int t =nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

