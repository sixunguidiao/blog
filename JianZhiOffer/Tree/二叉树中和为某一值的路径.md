# 题目

输入一颗二叉树的根节点和一个整数，打印出二叉树中所有路径和为target的所有路径。路径和为路径中所有节点的和，路径定义为从根结点向下到某个叶结点所经过的结点形成的一个序列。例如给定二叉树如下：

```
     10
    /  \
   5   12
  / \
 4   7
```

返回该二叉树中所有路径和为22的路径，则返回结果应该为：

```
[[10, 5, 7], [10, 12]]
```

# 思路

由于前序遍历是先从根节点开始访问，因此采用前序遍历处理。每遍历一个节点将当前节点的值进行累加，即target - root.val，同时将当前节点加入到path中。当遍历到叶节点并且target == 0时，将path加到res中。在函数回退的时候记得在path中删除当前节点。

```java
public List<List<Integer>> findPath(TreeNode root, int target) {
    if (root == null) return new ArrayList<>();
    List<List<Integer>> result = new ArrayList<>();
    helper(root, target, new ArrayList<>(), result);
    return result;
}

private void helper(TreeNode root, int target, List<Integer> path, List<List<Integer>> result) {
    if (root == null) return;
    target -= root.val;
    path.add(root.val);
    if (root.left == null && root.right == null && target == 0) {
        result.add(new ArrayList<>(path));	//注意，这里不能直接写成"result.add(path)"，那样相当于把path的引用传过去了，然而我们在下面遍历的过程中会改变path中的值，这样会导致之前加入result中的路径的内容也会跟着改变。应该用一个新的ArrayList来承载path的值。
    }
    helper(root.left, target, path, result);
    helper(root.right, target, path, result);
    path.remove(path.size() - 1);
}
```

