# 题目

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。例如输入数组 [5, 7, 6, 9, 11, 10, 8]，返回 true，因为这个整数序列是下图所示二叉搜索树的后序遍历结果。

```
     8
    / \
   6   10
  / \ /  \
 5  7 9  11
```

如果输入数组是 [7, 4, 6, 5]，由于没有哪棵二叉搜索树的后序遍历结果是这个序列，因此返回 false。

# 思路

在二叉搜索树的后序遍历序列中，最后一个是根节点，在根节点前所有小于根节点的数构成根节点的左子树，所有大于根节点的数构成根节点的右子树。据此可以在原数组中划分出左子树序列和右子树序列，其中左子树序列中的所有数都比根节点的值小，右子树序列中所有数的值都比根节点的值大。如果在右子树序列中出现小于根节点值的数，说明该序列不是二叉搜索树的后序遍历结果，返回 false。接着递归得在左子树序列和右子树序列中继续判断。

```java
public boolean verifySequenceOfBST(int[] nums) {
    if (nums == null || nums.length == 0) return false;
    return verifySequenceOfBSTCore(nums, 0, nums.length - 1);
}

private boolean verifySequenceOfBSTCore(int[] nums, int lo, int hi) {
    // special
    if (lo > hi) return false;
    if (lo == hi) return true;	// 如果lo == hi，说明当前子数组中只有一个元素，直接返回true
    int rootValue = nums[hi];	// 根节点的值
    int mid = lo;	//左子树序列和右子树序列的分界点，表示右子树序列的第一个元素，同时也表示左子树序列中元素的个数
    for (; mid < hi; mid++) {
        if (nums[mid] > rootValue) break;
    }
    for (int i = mid; i < hi; i++) {
        if (nums[i] < rootValue) return false;	// 如果在遍历右子树序列的过程中发现某个元素小于根节点值，直接返回false
    }
    boolean left = verifySequenceOfBSTCore(nums, lo, mid - 1);	// 判断左子树序列是不是后序遍历序列
    boolean right = verifySequenceOfBSTCore(nums, mid, hi - 1);	// 判断右子树序列是不是后序遍历序列
    return left && right;
}
```

