# 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 [1, 2, 4, 7, 3, 5, 6, 8] 和中序遍历序列 [4, 7, 2, 1, 5, 3, 8, 6]，则重建二叉树并返回。

# 思路

先根据前序序列的第一个数字创建根节点，接下来在中序序列中找到根节点的位置，这样就能确定左右子树节点的数量，然后在新的前序序列和中序序列中递归地构建其左子树和右子树。前序序列用 startPreorder 和endPreorder 两个变量确定，中序序列可以用 startInorder 和 endInorder 两个变量确定。

```java
public TreeNode reConstructBinaryTree(int[] preOrder, int[] inOrder) {
    if (preOrder == null || preOrder.length == 0 || inOrder == null || inOrder.length == 0)
        return null;
    return helper(preOrder, inOrder, 0, preOrder.length - 1, 0, inOrder.length - 1);
}

private TreeNode helper(int[] preOrder, int[] inOrder, int startPreorder, int endPreorder, int startInorder, int endInorder) {
    if (startPreorder > endPreorder || startInorder > endInorder) return null;
    int rootValue = preOrder[startPreorder];
    TreeNode root = new TreeNode(rootValue);
    int rootInorder = startInorder;	// 当前节点在中序序列中的位置
    while (rootInorder <= endInorder && inOrder[rootInorder] != rootValue) {
        rootInorder++;
    }
    int left = rootInorder - startInorder;  // 当前节点左子树中节点的个数
    root.left = helper(preOrder, inOrder, startPreorder + 1, startPreorder + left, startInorder, rootInorder - 1);
    root.right = helper(preOrder, inOrder, startPreorder + left + 1, endPreorder, rootInorder + 1, endInorder);
    return root;
}
```

