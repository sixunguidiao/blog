# 题目

输入两棵二叉树 A，B判断 B 是不是 A 的子结构。我们约定空树不是任意一个树的子结构。例如给定树 A：

```
    8
   / \
  8   7
 / \
9   2
   / \
  4   7
```

树 B：

```
  8
 / \
9   2
```

可知 B 是 A 的子结构。

# 思路

首先在 root1 中找到和 root2 的根节点的值一样的节点，然后判断该节点所代表的子树是不是和 root2 具有相同的结构。

```java
public boolean hasSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null && root2 == null) return true;	// 约定当root1和root2均为null，root2是root1的子结构，返回true
    if (root1 == null || root2 == null) return false;
    boolean isFound = false;
    if (root1.val == root2.val) isFound = helper(root1, root2);
    if (!isFound) isFound = hasSubtree(root1.left, root2) || hasSubtree(root1.right, root2);
    return isFound;
}

private boolean helper(TreeNode root1, TreeNode root2) {
    if (root2 == null) return true;	// 如果root2 == null，说明root1和root2之前的结构完全相同，这时就算root1 != null，也可以返回true
    if (root1 == null) return false;	// 如果roo1 == null，借由上一条语句知root2 != null，所以root1和root2的结构不相同，返回false
    if (root1.val != root2.val) return false;
    return helper(root1.left, root2.left) && helper(root1.right, root2.right);
}
```

# 扩展

LeetCode 572。和该题不同的是，这里要求树 B 和树 A 中的某个子树完全相同。例如给定树 A：

```
     3
    / \
   4   5
  / \
 1   2
```

树 B：

```
   4 
  / \
 1   2
```

返回 true。而给定树 A：

```
     3
    / \
   4   5
  / \
 1   2
    /
   0
```

树 B：

```
   4
  / \
 1   2
```

返回 false。

# 思路

上一题中假设在 A 中找到了和 B 的根节点的值相同的节点 root 后，只要求 root 所代表的子树中包含和 B 的结构完全一样的**结构**即可。而这里要求 root 所代表的子树和 B **完全一样**，即 root 及其所有后继节点都要和 B 完全一样。两者的区别在 helper() 函数的不同。

```java
public boolean hasSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null && root2 == null) return true;
    if (root1 == null || root2 == null) return false;
    boolean isFound = false;
    if (root1.val == root2.val) isFound = helper(root1, root2);
    if (!isFound) isFound = hasSubtree(root1.left, root2) || hasSubtree(root1.right, root2);
    return isFound;
}

private boolean helper(TreeNode root1, TreeNode root2) {
    // root1和root2同时访问到null才返回true，一个为null一个不为null或者两个节点的val值不相同都返回false
    if (root1 == null && root2 == null) return true;
    if (root1 == null || root2 == null) return false;
    if (root1.val != root2.val) return false;
    return helper(root1.left, root2.left) && helper(root1.right, root2.right);
}
```

