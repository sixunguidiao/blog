# 题目

输入两个整数序列，第一个序列表示栈的入栈顺序，请判断第二个序列是否可能为该栈的出栈顺序。假设压入栈的所有数字均不相等。例如序列1, 2, 3, 4, 5是某栈的入栈顺序，序列4, 5, 3, 2, 1是该入栈序列对应的一个出栈序列，但4, 3, 5, 1, 2就不可能是该入栈序列的出栈序列。两个序列的长度相等。

# 思路

使用一个辅助栈 stack。如果出栈序列中的当前元素刚好是栈顶元素，那么直接弹出。否则，我们把入栈序列中还没有入栈的数字压入 stack，直到把下一个需要出栈的元素压入栈为止。如果入栈序列中所有的数字都入栈了仍然没有找到下一个需要出栈的数字，那么该序列不可能是一个出栈序列。

```java
public boolean isPopOrder(int[] push,int[] pop) {
    if (push == null || push.length == 0 || pop == null || pop.length == 0) return false;
    Stack<Integer> stack = new Stack<>();
    int p1 = 0;	// 指示入栈序列中的元素
    int p2 = 0;	// 指示出栈序列中的元素
    while (p2 < pop.length) {
        while (stack.isEmpty() || stack.peek() != pop[p2]) {
            if (p1 == push.length) return false;	//如果入栈序列中的数字被压完了栈顶元素还不是当前需要出栈的元素，说明该序列不是一个出栈序列，返回false
            stack.push(push[p1++]);
        }
        stack.pop();
        p2++;
    }
    return stack.isEmpty();
}
```

