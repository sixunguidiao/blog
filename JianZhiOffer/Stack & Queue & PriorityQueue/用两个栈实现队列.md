# 题目

用两个栈实现一个队列，完成队列的入队 offer() 和出队 poll() 操作。 队列中的元素类型为 int。

# 思路

push 时将数 push 到 stack1中，pop 时，从 stack2 中pop，如果 stack2 为空，则先将 stack1 中的所有数 pop到 stack2 中再从 stack2 中 pop。

```java
class MyQueue {
    
    Stack<Integer> stack1;
    Stack<Integer> stack2;
    
    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void offer(int num) {
        stack1.push(num);
    }
    
    public int poll() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

# 扩展

用两个队列实现一个栈，完成栈的入栈 push() 和出栈 pop() 操作。 栈中的元素类型为 int。

# 思路

我们通过一系列栈的 push 和 pop 操作来分析两个队列模拟一个栈的过程。表格的第一列表示 queue1，第二列表示 queue2。现在我们向栈中依次 push 进1,2,3三个数，由于初始时 queue1 和 queue2 都是空的，因此插入哪个queue 都可以。我们不妨将1,2,3依次插入到 queue2，此时两个 queue 中元素的情况如下图所示：

```
queue1	queue2
          3
          2
          1
```

现在我们对栈执行 pop，由于栈的后进先出特性可知出栈元素应该是3，然而直接操作 queue2 的话会从队头删除元素，也就是删除1。此时我们可以先把 queue2 中的1,2插入到 queue1 中，再从 queue2 中删除3。执行出栈后两个 queue 中元素的情况如下图所示：

```
queue1	queue2
  
  2
  1
```

如果再执行一次 pop 的话，我们就把 queue1 中的1插入到 queue2 中，然后从 queue1 中删除1。

总结上述过程我们可以得到以下结论：整个过程中我们保持两个队列中至少一个队列为空。当执行 push 时，如果两个队列均为空，我们约定将元素插入到 queue2 中；如果两个队列一个未空，另一个不为空，我们将元素插入到那个非空的队列中。当执行 pop 时，我们不断将非空的那个队列中的元素出队，直到该队列只含有一个元素，此时该元素即为出栈的元素，我们将该元素出队并返回。

```java
class MyStack {
    
    Queue<Integer> queue1;
    Queue<Integer> queue1;
    
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    public void push(int num) {
        if (queue1.isEmpty()) {
            queue2.offer(num);
        } else {
            queue1.offer(num);
        }
    }
    
    public int pop() {
        if (!queue1.isEmpty()) {
            while (queue1.size() > 1) {
                queue2.offer(queue1.poll());
            }
            return queue1.poll();
        } else {
            while (queue2.size() > 1) {
                queue1.offer(queue2.poll());
            }
            return queue2.poll();
        }
    }
}
```