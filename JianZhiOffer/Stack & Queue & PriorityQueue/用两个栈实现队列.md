# 题目

用两个栈实现一个队列，完成队列的入队offer()和出队poll()操作。 队列中的元素类型为int。

# 思路

push时将数push到stack1中，pop时，从stack2中pop，如果stack2为空，则先将stack1中的所有数pop到stack2中再从stack2中pop。

```java
class MyQueue {
    
    Stack<Integer> stack1;
    Stack<Integer> stack2;
    
    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void offer(int num) {
        stack1.push(num);
    }
    
    public int poll() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

# 扩展

用两个队列实现一个栈，完成栈的入栈push()和出栈pop()操作。 栈中的元素类型为int。

# 思路

我们通过一系列栈的push和pop操作来分析两个队列模拟一个栈的过程。表格的第一列表示queue1，第二列表示queue2。现在我们向栈中依次push进1,2,3三个数，由于初始时queue1和queue2都是空的，因此插入哪个queue都可以。我们不妨将1,2,3依次插入到queue2，此时两个queue中元素的情况如下图所示：

```
queue1	queue2
          3
          2
          1
```

现在我们对栈执行pop，由于栈的后进先出特性可知出栈元素应该是3，然而直接操作queue2的话会从队头删除元素，也就是删除1。此时我们可以先把queue2中的1,2插入到queue1中，再从queue2中删除3。执行出栈后两个queue中元素的情况如下图所示：

```
queue1	queue2
  
  2
  1
```

如果再执行一次pop的话，我们就把queue1中的1插入到queue2中，然后从queue1中删除1。

总结上述过程我们可以得到以下结论：整个过程中我们保持两个队列中至少一个队列为空。当执行push时，如果两个队列均为空，我们约定将元素插入到queue2中；如果两个队列一个未空，另一个不为空，我们将元素插入到那个非空的队列中。当执行pop时，我们不断将非空的那个队列中的元素出队，直到该队列只含有一个元素，此时该元素即为出栈的元素，我们将该元素出队并返回。

```java
class MyStack {
    
    Queue<Integer> queue1;
    Queue<Integer> queue1;
    
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    public void push(int num) {
        if (queue1.isEmpty()) {
            queue2.offer(num);
        } else {
            queue1.offer(num);
        }
    }
    
    public int pop() {
        if (!queue1.isEmpty()) {
            while (queue1.size() > 1) {
                queue2.offer(queue1.poll());
            }
            return queue1.poll();
        } else {
            while (queue2.size() > 1) {
                queue1.offer(queue2.poll());
            }
            return queue2.poll();
        }
    }
}
```