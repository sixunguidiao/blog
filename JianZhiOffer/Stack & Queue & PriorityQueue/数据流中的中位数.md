# 题目

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数值的平均值。

# 思路

由于我们需要从一个数据流中读出数据并计算中位数，因此我们需要用一个数据容器存储数据流中的所有数据并同时考虑插入数据和读取中位数这两个操作的时间复杂度。

容易想到的是用一个数组保存数据流中的所有数据，如果数据是有序的，则我们在插入一个新数据到数据流时需要移动其他数据以保持数据的有序性，时间复杂度为 O(N)，读取中位数时由于数组是有序的因此直接读就可以了，时间复杂度是 O(1)。如果数组是无序的，插入数据的时间复杂度是 O(1)，读取中位数可以使用 partition 函数，时间复杂度为 O(N)（关于 partition 的时间复杂度分析比较复杂，详见《算法导论》）。

如果采用二叉搜索树作为数据容器的话，插入数据的平均时间复杂度是 O(logN)，读取中位数的平均时间复杂度为O(logN)，但是在最坏情况下，即二叉搜索树退化为一个单链表时，插入和读取的时间复杂度是 O(N)。我们可以使用一个改进的 AVL 树作为数据容器，将平衡因子定义为左右子树节点数据之差，这样插入的时间复杂度为O(logN)，读取的时间复杂为 O(1) (根节点的值或根节点和左子节点或右子节点的值的平均值)。但是大部分的编程语言没有实现我们定义的这种 AVL 树，因此我们需要再分析其他的方法。

假设数据在容器中已经排好序，中位数可以由 p1 和 p2 两个指针指向的数得到。如果容器中数据的数目是奇数，则中位数由 p1 和 p2 共同指向；如果容器中数据的数目是偶数，则中位数是 p1 和 p2 指向的数的平均值。注意到整个数据容器被我们分成了两部分，左边部分的数据比右边部分的数据小，并且 p1 指向的数据是左边部分最大的数，p2 指向的数据是右边部分最小的数，见下图：

| N<sub>1</sub> | N<sub>2</sub> | ...  | N<sub>m</sub> |       N<sub>m+1</sub>        | N<sub>m+2</sub> | ...  | N<sub>2m</sub> | N<sub>2m+1</sub> |
| :-----------: | :-----------: | :--: | :-----------: | :--------------------------: | :-------------: | :--: | :------------: | :--------------: |
|               |               |      |               | P<sub>1</sub>, P<sub>2</sub> |                 |      |                |                  |

| N<sub>1</sub> | N<sub>2</sub> | ...  | N<sub>m</sub> | N<sub>m+1</sub> | ...  | N<sub>2m-1</sub> | N<sub>2m</sub> |
| :-----------: | :-----------: | :--: | :-----------: | :-------------: | :--: | :--------------: | :------------: |
|               |               |      | P<sub>1</sub> |  P<sub>2</sub>  |      |                  |                |

因此我们可以用一个最大堆保存左边部分的数据，用一个最小堆保存右边部分的数据，p1 和 p2 分别指向最大堆和最小堆的堆顶。

在插入数据时我们需要确保数据被平均分配到两个堆中，即两个堆中数据的数目之差不能超过1。为了实现实现平均分配，我们约定在数据的总数目是偶数时把数据插入到最小堆中，否则插入到最大堆中。同时，我们还要保证最大堆中的所有数据都要小于最小堆中的数据。当数据的总数目是偶数时，按照我们的约定会把数据插入到最小堆中，如果这个数据比最大堆中的一些数据要小该怎么办呢？我们可以先把数据插入到最大堆中，然后拿出此时最大堆中最大的元素，即堆顶元素，将其插入到最小堆中，这样就保证了最小堆中的所有数字都大于最大堆中的数字。当需要把一个数据插入到最大堆但是这个数据比最小堆中的一些数据要大时同理进行分析。

采用最大堆和最小堆作为数据容器时，插入数据的时间复杂度为 O(logN)，读取中位数的时间复杂度为 O(1)。

```java
class DynamicArray {

    private PriorityQueue<Integer> max; // 最大堆
    private PriorityQueue<Integer> min; // 最小堆

    DynamicArray() {
        min = new PriorityQueue<>();
        max = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
    }

    // 向数据流中插入一个数据
    public void insert(int num) {
        int size = max.size() + min.size();	// 当前数据流中数据的总数
        if ((size & 1) == 0) {	// 如果当前数据流中数据的总数是偶数，将其插入到最小堆中
            if (max.size() > 0 && num < max.peek()) {
                max.offer(num);
                num = max.poll();
            }
            min.offer(num);
        } else {	// 如果当前数据流中数据的总数是奇数，将其插入到最大堆中
            if (min.size() > 0 && num > min.peek()) {
                min.offer(num);
                num = min.poll();
            }
            max.offer(num);
        }
    }

    // 获取当前数据流中所有数据的中位数
    public int getMedian() {
        int size = max.size() + min.size();	// 当前数据流中数据的总数
        if ((size & 1) == 0) {	// 如果数据流中数据的总数为偶数，返回中间的两个数的平均值
            return (max.peek() + min.peek()) / 2;	// 如果数据流中数据的总数为奇数，返回中间的数
        } else {
            return min.peek();  // 注意，虽然在前面的分析中，如果数据流中数据的总数是奇数，p1和p2同时指向数据流中间的那个数，这里无论是返回最小堆的堆顶元素还是最大堆的堆顶元素应该都是可以的。但是在实现上只有最小堆的堆顶才指示中间的那个数，因此这里只能返回最小堆的堆顶元素
        }
    }
}
```

