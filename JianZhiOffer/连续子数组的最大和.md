# 题目

给定一个数组，返回它的最大连续子序列的和，子序列的长度至少为1。例如给定数组[6,-3,-2,7,-15,1,2,2]，最大的子序列为[6,-3,-2,7]，输出8。

# 思路1

根据结论“连续子序列之和等于两个前缀和之差”，即设S<sub>i</sub> = A<sub>1</sub> + A<sub>2</sub> + ... + A<sub>i</sub>，则 A<sub>i</sub> + A<sub>i+1</sub> + ... + A<sub>j</sub> = S<sub>j</sub> - S<sub>i-1</sub>。

```java
public int FindGreatestSumOfSubArray(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int[] s = new int[nums.length];	// s[i]表示s[0, ..., i]中每个元素累加的和
    s[0] = nums[0];
    int result = Integer.MIN_VALUE;
    for (int i = 1; i < nums.length; i++) {
        s[i] = s[i - 1] + nums[i];
    }
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            result = Math.max(result, Math.max(s[i], s[i] - s[j]));
        }
    }
    return result;
}
```

时间复杂度：O(N^2)

# 思路2

dp。dp[i]表示nums[0, ..., i]中包含nums[i]的最大连续子序列的和，状态转移方程如下：

`dp[i] = max{nums[i], dp[i - 1] + nums[i]}`

```java
public int FindGreatestSumOfSubArray(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int result = Integer.MIN_VALUE;
    for (int i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
        result = Math.max(result, dp[i]);
    }
    return result;
}
```

时间复杂度：O(N)

