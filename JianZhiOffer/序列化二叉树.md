# 题目

实现两个函数，分别用来序列化和反序列化二叉树。

# 思路

我们知道，如果给定一棵二叉树的前序遍历序列和中序遍历序列，我们可以从中构造出一棵二叉树。因此我们可以先把一棵二叉树序列化成一个前序遍历序列和一个中序遍历序列，然后在反序列化时通过这两个序列重构出原二叉树。但是这个思路有两个缺点，一是二叉树中不能有数值重复的节点，否则我们无法通过这种方法构造出原二叉树。二是只有当两个序列中的数据都读出后才能开始反序列化。如果两个序列是从一个流中读出来的，那么可能就需要等待很长的时间。实际上如果二叉树的序列化是从根节点开始的话，那么相应的反序列化在根节点的数值读出来后就可以开始了。因此我们可以根据**前序遍历**来序列化和反序列化二叉树。在序列化时，如果当前节点不为空，我们在字符串中加入当前节点的值；如果当前节点为空，我们在字符串中加入一个特殊字符，比如`$`。在反序列化时，我们每次从字符流中读入一个字符，如果当前字符不是"$"，我们创建一个新节点，并继续构建该节点的左子树和右子树；否则，返回空。

例如给定如下的二叉树：

```
     1
    / \
   2   3
  /   / \
 4   5   6
```

序列化结果为：`1,2,4,$,3,5,$,$,6,$,$`

```java
// 序列化
private boolean isFirst = true;	// 指示当前正在序列化的节点是不是第一个节点

public String serialize(TreeNode root) {
    if (root == null) return "";
    StringBuilder sb = new StringBuilder();
    serializeCore(root, sb);
    return sb.toString();
}

private void serializeCore(TreeNode root, StringBuilder sb) {
    if (root == null) {
        if (isFirst) {
            sb.append("$");
            isFirst = false;
        } else {
            sb.append(",$");
        }
    } else {
        if (isFirst) {
            sb.append(root.val);
            isFirst = false;
        } else {
            sb.append("," + root.val);
        }
        serializeCore(root.left, sb);
        serializeCore(root.right, sb);
    }
}

// 反序列化
private int curr = 0;   // 指示序列化字符串中当前正在反序列的字符的下标

public TreeNode deserialize(String str) {
    if (str == null || str.length() == 0) return null;
    String[] strs = str.split(",");
    return deserializeCore(strs);
}

private TreeNode deserializeCore(String[] strs) {
    String val = strs[curr++];
    if (val.equals("$")) return null;
    TreeNode root = new TreeNode(Integer.parseInt(val));
    root.left = deserializeCore(strs);
    root.right = deserializeCore(strs);
    return root;
}
```

