# 题目

给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如如果输入数组[2,3,4,2,6,2,5,1]及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别是[4,4,6,6,6,5]。

# 思路

如果采用暴力法，可以扫描每一个滑动窗口中的所有数字找出其中的最大值，如果滑动窗口的大小为k，数组的大小为n，则这种方法时间复杂度为O(kn)，显然不是最优的。实际上，一个滑动窗口可以看成是一个队列。当窗口滑动时，处于窗口的第一个数字被删除，同时在窗口的末尾添加一个新的数字。这符合队列先进先出的特性。正常情况下我们需要扫描整个队列才能找到队列中的最大数，我们看看能不能在O(1)的时间内找到队列中的最大数。我们并不把滑动窗口里的每一个数都存入队列中，而是只把有可能成为滑动窗口最大值的数存入到一个双端队列中。我们使用队列的队头保存当前滑动窗口的最大值。当把数组前k个元素加入到队列中时，由于此时窗口还没有开始滑动，我们只需要在队列中保存前k个数字中最大的数即可，此时队列的队头就是当前窗口中最大的数。当窗口开始滑动时，一方面我们需要将当前数字和队列中的数字进行比较，如果当前数字比队列中的数字大，则队列中比当前数字小的元素不可能成为窗口的最大值，将其从队列中移除，另一方面，我们需要判断代表当前窗口最大值的队头元素是否已经滑出窗口，如果已经滑出窗口，我们也需要将其进行移除。那么如何判断当前窗口是否包含一个数字呢？我们需要在队列里存入数字在数组中的下标，而不是数值。当队头元素的下标与当前处理的数字的下标之差大于等于窗口的大小时，说明这个数字已经从窗口中滑出了。在实现上，我们使用一个双端队列deque保存有可能是滑动窗口最大值的数字的下标。在存入一个数字的下标之前，首先要判断队列里已有数字是否小于待存入的数字。如果已有数字小于待存入的数字，说明这些数字已经不可能是滑动窗口的最大值，因此它们会依次从队列的尾部删除（调用`deque.pollLast()`）。同时，如果队列头部的数字已经从窗口中滑出，滑出的数字也需要从队列的头部删除（调用`deque.pollFirst`）。由于队列头部和尾部都有可能删除数字，因此这也是我们需要双端队列的原因。

```java
public List<Integer> maxInWindows(int[] nums, int size) {
    if (nums == null || nums.length == 0 || size < 1 || size > nums.length) return new ArrayList<>();
    List<Integer> result = new ArrayList<>();
    Deque<Integer> deque = new LinkedList<>();

    for (int i = 0; i < size; i++) {
        while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
            deque.pollLast();
        }
        deque.offer(i); // 作用等同于deque.offerLast()
    }
    for (int i = size; i < nums.length; i++) {
        result.add(nums[deque.peekFirst()]);
        while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) { // 从尾部删除队列中等于或小于当前元素的元素，因为这些元素不可能成为滑动窗口的最大值
            deque.pollLast();
        }
        while (!deque.isEmpty() && i - deque.peekFirst() >= size) { // 从头部删除队列中已经滑出窗口的元素
            deque.pollFirst();
        }
        deque.offer(i);
    }
    result.add(nums[deque.peekFirst()]);

    return result;
}
```

