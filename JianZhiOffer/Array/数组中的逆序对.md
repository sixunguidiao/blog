# 题目

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数 P。如果前一个数字大于后一个数字，则这两个数字组成一个逆序对。输入一个数组，求出在这个数组中的逆序对的总数。例如，在数组 [7, 5, 6, 4] 中，一共存在5个逆序对，分别是 [7, 6],[7, 5],[7, 4],[6, 4],[5, 4]。

# 思路

如果顺序遍历数组，对于每个元素向后继续遍历数组统计其逆序对的数目，那么时间复杂度是 O(N^2)，显然效率很低。可以利用归并排序的思想。对于 [7, 5, 6, 4]，我们可以首先可以得到 [7], [5], [6], [4] 这4个子数组，然后将相邻的两个子数组归并成一个数组，同时统计逆序对的数目。比如 [7] 和 [5] 归并之后得 [5, 7]，逆序对数目为1；[6], [4] 归并之后得 [4, 6]，逆序对数目为1。接着再将 [5, 7] 和 [4,6] 进行归并并统计逆序对的数目。我们首先用一个指针 i 指向 [5, 7] 的最后一个元素7，另一个指针 j 指向 [4, 6] 的最后一个元素6，mid 指针指向两个子数组中间的元素，也就是第一个数组的最后一个元素7，比较 i 和 j 指向的元素7和6，同时将较大的元素保存到一个辅助数组 aux 中，aux 的长度等于两个数组的长度之和，我们用 index 指示这个辅助数组，初始时 index 指向 aux 的最后一个元素。因为7 > 6，所以7大于6前面所有的元素包括6，因此逆序对数目+ (j - mid)，之后我们将7放到 aux 的 index 处，同时 i 和 index 向前移动一个单位。接着判断5和6，因为5 < 6，所以不存在逆序对，我们把6放到aux 的 index 处，接着把 j 和 index 向前移动一个单位。以此类推，直到完成对原数组的排序并返回逆序对的总数。

```java
private int[] aux;	// 辅助数组

public int inversePairs(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    aux = new int[nums.length];	// 一次性分配辅助数组的空间
    return inversePairsCore(nums, 0, nums.length - 1);
}

private int inversePairsCore(int[] nums, int lo, int hi) {
    // special
    if (lo >= hi) return 0;

    int mid = lo + (hi - lo) / 2;
    int left = inversePairsCore(nums, lo, mid);	// 对左半部分数组进行排序并统计逆序对的数目
    int right = inversePairsCore(nums, mid + 1, hi);	// 对右半部分数组进行排序并统计逆序对的数目
    
    // 将nums[lo, ..., hi]拷贝给aux，nums用来承载排序后的结果
    for (int i = lo; i <= hi; i++) {
        aux[i] = nums[i];
    }
    
    // 归并排序的merge，在merge的过程中统计逆序对的数目
    int i = mid;
    int j = hi;
    int index = hi;
    int count = 0;	// 逆序对的数目
    while (i >= lo && j >= mid + 1) {
        if (aux[i] > aux[j]) {
            count += j - mid;
            nums[index--] = aux[i--];
        } else {
            nums[index--] = aux[j--];
        }
    }
    for (; i >= lo; i--) {
        nums[index--] = aux[i];
    }
    for (; j >= mid + 1; j--) {
        nums[index--] = aux[j];
    }

    return left + right + count;
}
```

