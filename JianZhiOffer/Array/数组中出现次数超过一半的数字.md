# 题目

给定一个大小为 n 的整数数组，找到出现次数大于 n / 2 的元素。假设数组非空并且出现次数大于 n / 2 的数总是存在。例如给定一个长度为9的数组 [1, 2, 3, 2, 2, 2, 5, 4, 2]，由于2在数组中出现了5次，因此输出2。**假设数组中出现次数大于 n / 2 的元素一定存在**。

# 思路1

如果我们将数组按从小到大进行排序，那么数组中出现次数超过一半的数字就是数组的中位数，直接返回排序后数组中间位置的那个数即可。

```java
public int majorityElement(int[] nums) {
   if (nums == null || nums.length == 0) return 0;
   int n = nums.length;
   Arrays.sort(nums);
   return nums[n / 2];
}
```

时间复杂度：O(NlogN)

空间复杂度：O(1)（取决于所用的排序算法）

# 思路2:

用一个 map 统计数组中每个数字的出现次数，然后遍历 map，找到出现次数大于 n / 2 的数并返回。

```java
public int majorityElement(int[] nums) {
   if (nums == null || nums.length == 0) return 0;
   int n = nums.length;
   Map<Integer, Integer> map = new HashMap<>();
    
   // 统计数组中每个数字的出现次数
   for (int num : nums) {
       map.put(num, map.getOrDefault(num, 0) + 1);
   }
   
   // 找到出现次数大于n/2的元素返回
   for (Map.Entry<Integer, Integer> e : map.entrySet()) {
       if (e.getValue() > n / 2) {
           return e.getKey();
       }
   }
    
   return 0;
}
```

时间复杂度：O(N)

空间复杂度：O(N)

# 思路3

下面这个方法是书中该题的第一个方法，我们称它为 partition 方法。它的思路是由于 partition 方法每次可以确定一个数在排序数组中的正确位置，因此当 partition 返回的值是 n / 2，则找到该数；当 partition 返回的值小于 n / 2，说明中位数在右半部分，继续在右半部分找；当 partition 返回的值大于 n / 2，说明中位数在左半部分，继续在左半部分找。

**注意**，这种方法能够得到正确结果的关键在于 partition 函数的设计。我们当时在学习数据结构这门课程时，都会学习快速排序，而快速排序的关键就是 partition 函数。partition 函数的思路是：每次我们从数组中选择一个数作为基准，将数组中所有比该数小的数排在它的左边，将数组中所有比该数大的数排在它的右边。由此，我们便确定了该数在排序数组中的正确位置。但是一般的数据结构书中对于 partition 函数的设计默认都为将数组中第一个数作为基准，**但是如果将这种 partition 函数应用于该题中则在某些测试用例下会产生死循环，当数组中存在大量重复元素时，partition 函数返回的 index 可能永远不等于 mid！**为此我们应该采用更为科学的 partition 函数的设计，即在当前数组中随机选取一个数作为基准。

```java
public int majorityElement(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    int lo = 0;
    int hi = nums.length - 1;
    int mid = nums.length / 2;
    int index = partition(nums, lo, hi);
    while (index != mid) {
        if (index < mid) {
            index = partition(nums, index + 1, hi);
        } else {
            index = partition(nums, lo, index - 1);
        }
    }
    return nums[mid];
}

private int partition(int[] nums, int lo, int hi) {
    if (lo == hi) return nums[lo];	// 由于下面的random.nextInt(hi - lo)要求hi - lo大于0，因此这里多加一个判断
    
    // 从当前数组中随机选择一个数作为基准数pivot
    Random random = new Random();
    int pivot_index = lo + random.nextInt(hi - lo);
    int pivot = nums[pivot_index];
    
    // 将pivot移到末尾
    swap(nums, pivot_index, hi);
    int store_index = lo;
    
    // 将所有小于pivot的数移到左边，此时，所有大于pivot的数自动聚集到右边
    for (int i = lo; i < hi; i++) {
        if (nums[i] < pivot) {
            swap(nums, store_index++, i);
        }
    }
    
    // 将pivot放到它最终的位置上
    swap(nums, store_index, hi);
    
    return store_index;
}

private void swap(int[] nums, int i, int j) {
    if (i != j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

时间复杂度：O(N)

空间复杂度：O(1)

# 思路4

下面这个方法是书中该题的第一个方法。数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此我们在遍历数组的时候用一个变量 num 保存当前出现次数最多的数，用另一个变量 count 保存它的出现次数和其他数的出现次数抵消后的值。如果当前数和 num 相同，则count++；如果当前数和 num 不同，则 count--；如果 count 减为0，则将 num 置为当前数字并将 count 置为1。遍历结束后如果数组中超过一半的数字确实存在，那么 count = 1，num 即为该数。例如对于 nums = [1, 2, 3, 2, 2, 2, 5, 4, 2]，1, 2中1和2的出现次数相互抵消，3, 2中3和2的出现次数相互抵消，2, 2, 5, 4中2和5, 4的出现次数相互抵消，最后 num = 2，即为数组中出现次数最多的数。

```java
public int majorityElement(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    int num = nums[0];
    int count = 1;
    
    for (int i = 1; i < nums.length; i++) {
        if (count == 0) {
            num = nums[i];
            count = 1;
        } else if (nums[i] == num) {
            count++;
        } else {
            count--;
        }
    }
    
    return num;
}
```

时间复杂度：O(N)

空间复杂度：O(1)

