# 题目

把只包含质因子2, 3和5的数称作丑数 Ugly Number。例如6, 8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n 个丑数。约定1是第一个丑数。

# 思路

首先摒弃逐一判断 1 - n 中每个数是不是丑数的方法，因为那样对每个数即使是非丑数都要进行求余和除法的操作，时间效率很低。可以事先求出 1 - n 的每个丑数并将其排好序存在一个数组里，例如 [1, 2, 3, 4, 5, 6, 8, ...]。假设当前数组中最大的丑数是 M，小于 M 的丑数已经求出，我们需要求出 M 的下一个丑数是多少。我们可以将 M之前的丑数分别 * 2，找到第一个大于 M 的数，对于3和5同理，然后再从2, 3, 5中找到一个最小的数作为下一个丑数。但是这样需要把 M 之前的所有丑数都乘以2, 3, 5，其实这并不是必须的，由于数组是排好序的，对于乘以2而言，数组中肯定存在一个数 T2，在它之前的丑数乘以2都小于已有的最大丑数，而它之后的丑数乘以2又太大，我们只需要记录这个丑数的位置并且在每次求出当前数组的最大丑数时更新这个 T2 即可。对于3, 5同理。

```java
public int getUglyNumber(int n) {
    if (n < 1) return 0;
    int[] nums = new int[n];
    nums[0] = 1;
    int p2 = 0;
    int p3 = 0;
    int p5 = 0;
    int nextIndex = 1;
    
    while (nextIndex++ < n) {
        int nextNum = Math.min(nums[p2] * 2, Math.min(nums[p3] * 3, nums[p5] * 5));
        nums[nextIndex] = nextNum;
        while (nums[p2] * 2 <= nextNum) {
            p2++;
        }
        while (nums[p3] * 3 <= nextNum) {
            p3++;
        }
        while (nums[p5] * 5 <= nextNum) {
            p5++;
        }
    }
    
    return nums[nextIndex - 1];	// or return nums[n - 1];
}
```

