# 题目

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O(N)，空间复杂度是 O(1)。

# 思路

先考虑一种简单的情况，数组中只有一个数出现1次，其他数都是出现2次。我们可以从头到尾遍历数组，对每个数求异或， (因为一个数和自己异或的结果为0，因此所有出现两次的数都抵消掉了)，最后得到的结果就是那个只出现一次的数。现在我们考虑数组中恰有两个数出现1次，其他数都是出现两次。首先，从头到尾遍历数组，对每个数求异或，得到数 temp。在异或的过程中，由于所有出现2次的数都抵消掉了，所以 temp 是数组中那两个只出现1次的数异或的结果。由于这两个数不相同，所以 temp 肯定不为0，即 temp 的二进制表示中一定有一位为1。假设其第 n 位为1。我们根据数组中每个数的二进制中的第 n 位是否为1,可以把原数组分成两个数组，可知，出现2次的数一定被分到了一个数组当中。接着，我们分别对两个数组按照开始的思路求异或，即可得到两个出现1次的数。

```java
public int[] findNumsAppearOnce(int[] nums) {
    if (nums == null || nums.length == 0) return new int[]{};
    int[] result = new int[2];
    int temp = 0;

    for (int num : nums) {
        temp ^= num;
    }
    int index = findFirstBitOne(temp);
    for (int num : nums) {
        if (isBitOne(num, index)) {
            result[0] ^= num;
        } else {
            result[1] ^= num;
        }
    }

    return result;
}

// 返回num的二进制表示中从右向左第一个1的位置
private int findFirstBitOne(int num) {
    int index = 0;
    for (int i = 0; i < 32; i++) {
        if ((num & 1) == 1) return index;
        num >>= 1;
        index++;
    }
    return index;
}

// 返回num的二进制表示的第index位是不是1
private boolean isBitOne(int num, int index) {
    return ((num >> index) & 1) == 1;
}
```

