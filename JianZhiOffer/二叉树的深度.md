# 题目

输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长的路径的长度为树的深度。

# 思路

当根节点为空时，返回0；否则，返回左子树的深度和右子树的深度的最大值并加1。

```java
public int depth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(depth(root.left), depth(root.right)) + 1;
}
```

# 扩展

平衡二叉树。输入一棵二叉树，判断该二叉树是否是平衡二叉树。一个二叉树是平衡二叉树指的是树中所有节点的左子树的深度和右子树的深度差的绝对值不超过1。

# 思路

后序遍历该二叉树，求出当前节点左子树的深度left和右子树的深度right，判断left和right的差的绝对值是否大于1，如果是，说明该二叉树不是平衡二叉树。下面的代码中函数`isBalanced()`返回当前节点的深度。

```java
boolean isBalanced;

public boolean isBalancedTree(TreeNode root) {
    if (root == null) return true;
    isBalanced = true;
    isBalancedTreeCore(root);
    return isBalanced;
}

private int isBalancedTreeCore(TreeNode root) {
    if (root == null) return 0;
    int left = isBalancedTreeCore(root.left);
    int right = isBalancedTreeCore(root.right);
    int diff = Math.abs(left - right);
    if (diff > 1) isBalanced = false;
    return Math.max(left, right) + 1;
}
```

