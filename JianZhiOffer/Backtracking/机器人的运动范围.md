# 题目

地上有一个 m 行 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于 k 的格子。请问问该机器人能够到达多少个格子。例如给定threshold = 5, rows = 7, cols = 7，返回21。

# 思路

回溯法。在进入一个新的格子之前先判断是否能进入，如果能进入则 count++ 并且置访问标记为 true。

```java
// 表示上、下、左、右4个方向
private static final int[] DIR_X = {0, 0, -1, 1};
private static final int[] DIR_Y = {-1, 1, 0, 0};

public int movingCount(int threshold, int rows, int cols) {
    if (threshold < 0 || rows < 1 || cols < 1) return 0;
    return movingCountCore(threshold, 0, 0, rows, cols, new boolean[rows][cols]);
}

private int movingCountCore(int threshold, int i, int j, int rows, int cols, boolean[][] vis) {
    int count = 0;
    if (i >= 0 && i < rows && j >= 0 && j < cols && !vis[i][j] && getDigitSum(i) + getDigitSum(j) <= threshold) {
        vis[i][j] = true;
        count++;
        for (int k = 0; k < 4; k++) {
            int new_i = i + DIR_Y[k];
            int new_j = j + DIR_X[k];
            count += movingCountCore(threshold, new_i, new_j, rows, cols, vis);
        }
        // 由于这里需要找出所有能够到达的格子，已经访问过的格子不能再次进入，因此不能添加vis[i][j] = false
    }
    return count;
}

// 返回num各个数位相加的和
private int getDigitSum(int num) {
    if (num == 0) {
        return 0;
    }
    int sum = 0;
    while (num > 0) {
        sum += num % 10;
        num /= 10;
    }
    return sum;
}
```

