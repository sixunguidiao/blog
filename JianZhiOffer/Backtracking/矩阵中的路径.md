# 题目

设计一个函数，用来判断一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。

# 思路

 一个可以用回溯法解决的典型题。首先在矩阵中任选一个格子作为路径的起点。设矩阵中的当前字符为`matrix[i][j]`，路径字符串的当前字符为str(curr)。如果`str(curr) != matrix[i][j]`，说明矩阵中的当前字符不能构成路径，需要进行回溯。如果`str(curr) == matrix[i][j]`，说明当前字符能够构成路径，我们继续从当前字符出发分别沿着上、下、左、右4个方向继续寻找路径中的下一个字符str(curr + 1)。此外，由于在寻找路径的过程中已经访问过的格子不能重复进入，因此我们还需要定义一个访问数组vis。

```java
// 表示上、下、左、右4个方向
private static final int[] DIR_X = {0, 0, -1, 1};
private static final int[] DIR_Y = {-1, 1, 0, 0};

public boolean hasPath(char[][] matrix, String str) {
    if (matrix == null || matrix.length() == 0 || matrix[0].length == 0 || str == null || str.length() == 0)
        return false;
    int rows = matrix.length;	// 矩阵的行数
    int cols = matrix.length[0];	// 矩阵的列数
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (hasPathCore(matrix, i, j, str, 0, new boolean[rows][cols])) {
                return true;
            }
        }
    }
    return false;
}

private boolean hasPathCore(char[][] matrix, int i, int j, String str, int curr, boolean[][] vis) {
    if (curr == str.length()) {
        return true;
    } else {
        int rows = matrix.length;
        int cols = matrix[0].length;
        boolean hasPath = false;
        if (i >= 0 && i < rows && j >=0 && j < cols && !vis[i][j] && matrix[i][j] == str.charAt(curr)) {
            vis[i][j] = true;
            for (int k = 0; k < 4; k++) {
                int new_i = i + DIR_Y[k];
                int new_j = j + DIR_X[k];
                hasPath = hasPathCore(matrix, new_i, new_j, str, curr + 1, vis);
                if (hasPath) break;
            }
            vis[i][j] = false;
        }
        return hasPath;
    }
}
```

