# 题目

一个链表中包含环，找到环的入口节点。

# 思路1

从头开始遍历链表，用一个set保存已经走过的节点。当当前节点已经存在于set中时，说明链表中有环并且当前节点就是环的入口节点。

代码略。

# 思路2：

我们先来分析这样一个问题：如何判断一个链表中是否存在环？我们可以让一个快指针fast和一个慢指针slow同时从链表的第一个节点开始向前走，fast每次走2步，slow每次走1步。如果两个指针相遇则说明链表中存在环，如果fast走到链表的末尾两个指针还没有相遇则说明链表中不存在环。现在我们再设置一个指针p从链表的第一个节点开始向前走，每次走1步，slow从相遇的地方继续向前走，每次也走1步，当p和slow相遇时，相遇节点就是环的入口节点。

证明：设entry为环的入口节点。当slow和fast相遇时，设slow走过的路程为A+B，其中A为head到entry的路程，B为slow在环中走过的路程，N为环的长度。由于相遇时fast比slow多走了一圈，因此fast走过的路程为A+B+N (1)，同时由于slow每次走1步，fast每次走2步，所以fast走过的路程又可以表示为2A+2B (2)。联立(1)和(2)得A+B=N，所以相遇节点到entry的距离和head到entry的距离是相同的。

```java
private ListNode entryNodeOfLoop(ListNode head) {
    if (head == null || head.next == null) return null;
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) break;
    }
    if (fast == null || fast.next == null) return null;    // 链表中没有环
    ListNode p = head;
    while (p != slow) {
        p = p.next;
        slow = slow.next;
    }
    return p;
}
```

# 思路3

书上的方法。定义两个指针，设环中有n个节点，先让第一个指针从链表头开始在链表上走n个单位，然后两个指针再一起走，每次走一个单位。当两个指针相遇时，相遇节点就是环的入口节点。关键是如何求出环中的节点个数。借由上一题的分析，我们可以让slow从相遇节点处继续向前走，并记录走过的节点个数，当再次回到这个节点时，即可得出环中的节点个数。

```java
public ListNode entryNodeOfLoop(ListNode head) {
   if (head == null || head.next == null) return null;
   ListNode meetingNode = findMeetingNode(head);
   if (meetingNode == null) return null;
   ListNode curr = meetingNode;
   int nodesInLoop = 1;  // 环中的节点个数
   while (curr.next != meetingNode) {
       curr = curr.next;
       nodesInLoop++;
   }
   ListNode fast = head;
   for (int i = 0;i < nodesInLoop; i++) {
       fast = fast.next;
   }
   ListNode slow = head;
   while (slow != fast) {
       slow = slow.next;
       fast = fast.next;
   }
   return slow;
}

// 如果链表中存在环，返回slow和fast相遇的节点；如果链表中不存在环，返回null
private ListNode findMeetingNode(ListNode head) {
   if (head == null || head.next == null) return null;
   ListNode slow = head;
   ListNode fast = head;
   while (fast != null && fast.next != null) {
       slow = slow.next;
       fast = fast.next.next;
       if (slow == fast) return slow;
   }
   return null;
}
```

