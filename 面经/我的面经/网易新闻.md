# 网易新闻

## 一面

**自我介绍**

**项目 (问了很久)**

**HashMap 扩容说一下，具体是怎么做的**

**假如现在有一个 Redis 集群，集群中有8个节点，我们拿到一个数据需要先计算这个数据的 hash 值然后模8插入到这个集群的某个节点中。现在8个节点快满了，另外提供给你8个节点，也就是总共16个节点，需要把集群中的所有数据重新映射到这个具有16个节点的新集群中，怎么做？ (线上环境，不能设安全点，即既要把扩容做了，又要保证用户能取到之前集群中的数据)**

{

我们新建一个线程来做扩容这件事情，扩容其实就是用每个数据的 hash 模16放到新的节点中。但是在扩容的时候必须保证用户能够请求到数据，容易想到的一种做法是，我们保持数据在原来的节点中不变，把每个数据复制在新节点中复制一份。但是显然这种做法会占用额外的空间，因为数据在从老节点复制到新节点后，并没有在老节点中删除。

既然又要扩容，又要保证用户能够请求到数据，又不占用额外空间，那么扩容线程做的事情应该是在数据从老节点复制到新节点后，将老节点上的数据删除。

那么用户应该如何请求数据呢？先考虑这样一种情况，用户先去新节点上取数据，如果新节点上没有数据，说明数据还在老节点上，再去老节点上取数据。这样看似可行，实际上是有问题的。用户先去新节点上取数据，如果没有取到，可能扩容线程正在把老节点上的数据复制到新节点。当用户再去老节点上取数据时，可能数据已经被转移到了新节点了，老节点上的数据已经被删除了，所以用户就取不到数据了。

实际上我们只要更改一下用户请求数据的顺序就行了，即先去老节点上取数据，再去新节点上取数据。当用户在老节点上取数据没取到，说明数据已经被转移到了新节点，老节点上的数据已经被删除了，所以此时再去新节点上取就保证能取到了。

}

**快排时间复杂度，partition复杂度，为什么是 O(N)**

{

**partition 函数**

快速排序中用到的 partition 算法思想很简单，首先从无序数组中选出枢轴点 pivot，然后通过一趟扫描，以 pivot 为分界线将数组中其他元素分为两部分，使得左边部分的数小于等于枢轴，右边部分的数大于等于枢轴（左部分或者右部分都可能为空），最后返回枢轴在新的数组中的位置。

Partition 的一个直观简单实现如下（这里取数组的随机的一个元素作为 pivot）：

```java
public int partition(int[] nums, int lo, int hi) {
    if (lo == hi) return lo;
    Random random = new Random();

    // 取数组中随机的一个元素作为pivot
    int pivot_index = lo + random.nextInt(hi - lo); // hi - lo should be positive
    int pivot = nums[pivot_index];

    swap(nums, pivot_index, lo);    // 将pivot交换到数组的第一个位置
    int pos = lo;   // 指示pivot最终放置的位置
    for (int i = lo + 1; i <= hi; i++) {
        if (nums[i] <= pivot) {
            pos++;
            swap(nums, i, pos); // pos位置上的元素始终小于或等于pivot
        }
    }
    swap(nums, pos, lo);
    return pos;
}

private void swap(int[] nums, int i, int j) {
    if (i != j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

如果原始数组为 [5, 9, 2, 1, 4, 7, 5, 8, 3, 6]，那么整个处理的过程如下图所示：

![1552826598360](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1552826598360.png)

这种实现思路比较直观，但是其实并不高效。从直观上来分析一下，每个小于 pivot 的值**基本上**（除非到现在为止还没有遇见大于 pivot 的值）都需要一次交换，大于 pivot 的值（例如上图中的数字9）有可能需要被交换多次才能到达最终的位置。

如果我们考虑用双指针的思想，保持头尾两个指针向中间扫描，每次在头部找到大于 pivot 的值，同时在尾部找到小于 pivot 的值，然后将它们做一个交换，就可以一次把这两个数字放到最终的位置。一种比较明智的写法如下：

```java
private int partition(int[] nums, int lo, int hi) {
    if (lo == hi) return lo;
    Random random = new Random();

    // 取数组中随机的一个元素作为pivot
    int pivot_index = lo + random.nextInt(hi - lo); // hi - lo should be positive
    int pivot = nums[pivot_index];

    swap(nums, pivot_index, lo);
    int i = lo;
    int j = hi + 1;
    while (i < j) {
        while (i < j && nums[--j] >= pivot);
        nums[i] = nums[j];
        while (i < j && nums[++i] <= pivot);
        nums[j] = nums[i];
    }
    nums[i] = pivot;    // or nums[j] = pivot

    return i;
}

private void swap(int[] nums, int i, int j) {
    if (i != j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

这里没有用到 swap 函数，但其实也相当于做了 swap 操作。以前面的数组为例，看看以这种方法来做的话，整个处理的流程。

![1552829591064](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1552829591064.png)

直观上来看，赋值操作的次数不多，比前面单向扫描的 swap 次数都少，效率应该会更高。

partition 函数的时间复杂度为 O(N)。(无论是上面的第一种方法还是第二种方法，最坏情况下数组中的每个数都要被访问一次，因此时间复杂度为 O(N))

[被忽视的 partition 算法](https://selfboot.cn/2016/09/01/lost_partition/)

}

**设计一个算法求一个数组的第 k 大的数**

{

求一个数组的第 k 大的数即是求这个数组排序后的第倒数第 k 个数。利用 partition 函数每次可以排定一个元素在排序数组中的位置这个特性即可解决。

```java
public int findKthNumber(int[] nums, int k) {
    if (nums == null || nums.length == 0 || k < 1) return -1;
    int lo = 0;
    int hi = nums.length - 1;
    int res_index = nums.length - k;	// 第k大的数在排序数组中的下标
    int index = partition(nums, lo, hi);

    while (index != res_index) {
        if (index < res_index) {
            index = partition(nums, index + 1, hi);
        } else {
            index = partition(nums, lo, index - 1);
        }
    }

    return nums[res_index];
}

private int partition(int[] nums, int lo, int hi) {
    if (lo == hi) return lo;
    Random random = new Random();

    // 取数组中随机的一个元素作为pivot
    int pivot_index = lo + random.nextInt(hi - lo); // hi - lo should be positive
    int pivot = nums[pivot_index];

    swap(nums, pivot_index, lo);
    int i = lo;
    int j = hi + 1;
    while (i < j) {
        while (i < j && nums[--j] >= pivot);
        nums[i] = nums[j];
        while (i < j && nums[++i] <= pivot);
        nums[j] = nums[i];
    }
    nums[i] = pivot;    // or nums[j] = pivot

    return i;
}

private void swap(int[] nums, int i, int j) {
    if (i != j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

}

**堆排序分为哪几步，建堆时间复杂度是多少**

{

分为两步，先建堆，再排序。给定一个无序数组，将该无序数组看成是一个完全二叉树，遍历树中的每个非叶节点，对每个节点做下沉操作，即可得到一个堆。

假设我们得到的是一个最大堆，即堆顶元素是当前数组中最大的元素，现在我们将数组中的所有数按升序排列。交换堆顶元素和堆中最后一个元素，然后对新的堆顶元素做下沉操作。不断重复上述操作直到树中所有节点从上到下，从左到右构成一个升序序列。

建堆的时间复杂度是 O(N)。

}

**除了 javac，java，你还知道哪些 java 命令行指令，做过 jvm 调优吗**



## 二面

**说说你知道的关于树的数据结构，J.U.C 包中有哪些数据结构**

{

二叉树，多叉树，完全二叉树，满二叉树，森林，平衡二叉树，红黑树，B 树，B+ 树，哈夫曼树，字典树，决策树，随机森林...

J.U.C 包中有哪些数据结构这个问题，我猜面试官是想问我阻塞队列，这个知识点掌握的不是很牢固，需要再巩固一下。

}

**Spring bean 的加载过程，生命周期**

{

加载过程：



生命周期：



}

**垃圾收集算法，垃圾收集器**

{



}

**Maven 的好处**

{



}

**实现字符串的 contains 方法 (也就是 indexOf 方法)**

{



}

**给你两个线程，一个线程负责打印偶数，一个线程负责打印奇数，调用两个线程顺序打印出0-100**

{



}