# BIO, NIO, AIO

## BIO：同步阻塞，一个连接对应一个线程
JDK 1.4 出来之前，我们建立网络连接都是采用 BIO 模式。客户端每发起一个连接请求，服务器都要为这个连接建立一个线程。当客户端和服务器之间有数据传输时，这个线程会负责相应的数据传输工作，然而当客户端和服务器之间没有数据传输时，这个线程仍然会占用系统内存。当并发上来后，服务器需要建立大量的线程，虽然可以采用线程池技术减小线程的管理成本，然而操作系统本身对线程的总数也有一定的限制，如果客户端请求过多，仍然会造成服务器崩溃的问题。

## NIO：同步非阻塞，一个请求对应一个线程

Java 1.4 之后引入了 NIO。我们可以在一个线程中建立一个 Selector 选择器，然后将多个 Socket 连接注册到这个选择器上。选择器会轮询所有的连接，当有连接需要传输数据时，线程才会去处理。这样我们用一个线程就可以处理多个连接的数据传输请求了。但是 NIO 还是会出现一些问题，当线程处理请求时，需要一些后端系统进行交互，比如操作系统、数据库等。在线程等待后端系统处理结果的过程中，线程会被阻塞，这样当并发上来后，仍然会影响系统的性能。

![img](https://images2015.cnblogs.com/blog/37237/201512/37237-20151222220329015-207666376.png)

## AIO：异步非阻塞，一个有效请求对应一个线程

我们假设后端系统有一个任务队列，线程把请求和一些参数放到这个队列中后立刻返回，在后端系统处理请求的过程中线程可以去处理其他请求，当后端系统处理完毕后将处理结果交给线程，线程再接着处理这个请求。这就是 AIO。

## Java 对 BIO，NIO和AIO的支持

- Java BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
- Java NIO：Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询所有连接，当连接有 I/O 请求时才启动一个线程进行处理。
- Java AIO (NIO.2)：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。

## 参考资料

[同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO](<https://blog.csdn.net/u011635492/article/details/81006328>)

