# 《鸟哥的Linux私房菜 基础学习篇》学习笔记

## 4.1.4 在终端界面登入 Linux

```
zq@ubuntu-01:~$
```

上面一行是正确登入之后才显示的讯息，最左边的 zq 表示目前用户的账号，而 @ 之后接的 ubuntu-01 则是主机名，至于最右边的 ~ 则指的是目前所在的目录，这里指的是用户的家目录，它是个变量。举例来说，root 的家目录在 /root，所以 ~ 就代表 /root 的意思。而 dmtsai 的家目录在 /home/dmtsai。

至于提示字符方面，在 Linux 当中，默认 root 的提示字符为 #，而一般身份用户的提示字符为 $。

注销：

```
exit
```

**注意：注销并不是关机！**基本上，Linux 本身已经有相当多的工作在进行，你的登入也仅是其中的一个工作而已，所以当你离开时，这次这个登入的工作就停止了，但此时 Linux 其他的工作还是在继续进行的。

## 4.2.1 开始下达指令

```
$ command [-options] parameter1 parameter2 ...
	指令		选项		参数1		  参数2
```

上述指令详细说明如下：

1. command 为指令的名称，例如变换工作目录的指令为 cd 等等；

2. 中括号 [] 并不存在于实际的指令中，而加入选项设定时，通常选项前会带 - 号，例如 -h；有时候会使用选项的完整全名，则选项前带有 -- 号，例如 --help；

3. parameter1 parameter2 ... 为依附在选项后面的参数，或者是 command 的参数；
4. 指令，选项，参数之间以空格来区分，不论空几格 shell 都视为一格。**所以空格是很重要的特殊字符**；

5. 按下 Enter 键后，该指令就立即执行。Enter 按键代表着一行指令的开始启动；
6. 指令太长的时候，可以使用 \ 来跳脱 Enter 符号，使指令连续到下一行；
7. 在 Linux 系统中，英文大小写字母是不一样的。举例来说，cd 与 CD 并不同；

## 4.2.3 重要的几个按键 [Tab]，[ctrl] + c，[ctrl] + d

- [Tab]

[Tab] 接在一串指令的第一个字的后面，为命令补全；

[Tab] 接在一串指令的第二个字以后时，则为文件补齐；

若安装 bash-completion 软件，则在某些指令后面使用 [Tab] 按键时，可以进行选项/参数补齐功能；

- [ctrl] + c

中断目前程序。

- [ctrl] + d

键盘输入结束 (EOF)。

- [shift] + [Page Up]/[shift] + [Page Down]

向前/向后翻页。

## 4.3 Linux 系统的在线求助 man page 与 info page

- help

```
date --help
```

通常，--help 用在协助你查询你曾经用过的指令所具备的选项与参数而已，如果你要使用的是从来没有用过的指令，或者是你要查询的指令根本就不是指令，而是文件的格式时，就要使用 man page了。

- man page

例如：

```
man date
```

首先，在表格的第一行，你可以看到的是：DATE(1)，DATE 我们知道是指令的名称，那么 (1) 代表什么呢？他代表的是一般用户可使用的指令的意思。常见的几个数字的意义是这样的：

| 代号 |                           代表内容                           |
| :--: | :----------------------------------------------------------: |
|  1   |     **用户在 shell 环境中可以操作的指令或可执行的文件**      |
|  2   |                 系统核心可呼叫的函数与工具等                 |
|  3   | 一些常用的函数 (function) 与函式库 (library)，大部分为 C 的函式库 (libc) |
|  4   |             装置文件的说明，通常在 /dev 下的文件             |
|  5   |                **配置文件或是某些文件的格式**                |
|  6   |                         游戏 (games)                         |
|  7   | 惯例与协议灯光，例如 Linux 文件系统、网络协议、ASCII code 等的说明 |
|  8   |                 **系统管理员可用的管理指令**                 |
|  9   |                     跟 kernel 有关的文件                     |

man page 下的常用按键：

|   按键    |          进行工作          |
| :-------: | :------------------------: |
|  空格键   |         向下翻一页         |
|  Page Up  |         向上翻一页         |
| Page Down |         向下翻一页         |
|   Home    |         去到第一页         |
|    End    |        去到最后一页        |
|  /string  | 向下搜寻 string 这个字符串 |
|  ?string  | 向上搜寻 string 这个字符串 |
|           |    结束这次的 man page     |

- info

略。

**总结**

- 在终端机模式中，如果你知道某个指令，但却忘记了相关选项与参数，请先善用 --help 功能来查询相关信息；

- 当有任何你不知道的指令或文件格式，但是你想要了解它，使用 man 或 info 来查询；

- 而如果你想要架设一些其他服务，或想要利用一组软件来达成某项功能时，到 usr/share/doc 底下查一查有没有该服务的说明档。

## 4.5 正确的关机方法

- 观察系统的使用状态

如果要看目前有谁在线，可以下达 who 这个指令，而如果要看网络的联机状态，可以下达 netstat -a 这个指令，而要看背景执行的程序可以下达 ps -aux 这个指令。使用这些指令可以让你稍微了解主机目前的状态。

- 数据同步写入磁盘：sync

## 5.2.1 Linux 文件权限属性

![1554452804907](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1554452804907.png)

1. 第一栏代表这个文件的类型和权限 (permission)；

仔细看的话，你应该可以发现这一栏其实共有10个字符：

- 当为 d 则是目录；
- 当为 - 则是文件;

- 若是 l 则表示连结档 (link file)；
- 若是 b 则表示为装置文件里面的可供储存的接口设备 (可随机存取装置)；
- 若为 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标 (一次性读取装置)；

接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合，其中 r 代表可读 (read)，w 代表可写 (write)，x 代表可执行 (execute)。要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。

- 第一组为 文件拥有者可具备的权限；
- 第二组为加入此群组的账号的权限；
- 第三组为非本人且没有加入本群组的其他账号的权限；

另外，**目录和文件的权限意义并不相同**。

2. 第二栏表示有多少档名连结到此节点 (i-node)；

每个文件都会将它的权限和属性记录到文件系统的 i-node 中，不过我们使用的目录树却是使用文件名来记录，因为每个档名就会连结到一个 i-node。这个属性记录的就是有多少不同的档名连结到相同的一个 i-node 号码去就是了。

3. 第三栏表示这个文件或目录的拥有者账号；
4. 第四栏表示这个文件的所属群组；
5. 第五栏为这个文件的容量大小，默认单位为 bytes；

6. 第六栏为这个文件的建档日期或者是最近的修改日期；

7. 第七栏为这个文件的档名；

比较特殊的是，如果档名之前多一个.，则代表这个文件为隐藏档。

## 5.2.2 如何改变文件属性和权限

- chgrp：改变我呢间所属群组
- chown：改变文件拥有者
- chmod：改变文件的权限

什么时候要使用 chown 或 chgrp 呢？最常见的例子就是在复制问阿金给你之外的其他人时，由于复制行为 (cp) 会复制执行者的属性与权限，所以你就必须要将这个文件的拥有者与群组修改一下了。

- 改变权限，chmod

1. 数字类型改变文件权限

各权限的分数对照表如下：

```
r:4
w:2
x:1
```

每种身份 (owner/group/others) 各自的三个权限 (r/w/x) 分数是需要累加的，例如当权限为：[-rwxrwx---]，分数则是

```
owner = rwx = 4 + 2 + 1 = 7
group = rwx = 4 + 2 + 1 = 7
others = --- = 0 + 0 + 0 = 0
```

变更权限的指令 chmod 的语法是这样的：

![1554454524467](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1554454524467.png)

2. 符号类型改变文件权限

我们可以借由u, g, o 来代表 user, group, others 三种身份的权限，此外 a 代表 all 即全部的身份，那么读写的权限就可以写成 r, w, x，见下表：

![1554454668280](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1554454668280.png)

假如我们要设定一个文件的权限称为 -rwxr-xr-x，语法为：

![1554454723275](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1554454723275.png)

## 5.2.3 目录与文件之权限意义

1. 权限对文件的重要性

文件是实际含有数据的地方，包括一般文本文件，数据库内容文件，二进制可执行文件 (binary program) 等待。因为权限对于文件来说，它的意义是这样的：

- r (read)：可读取此文件的内容，如读取文本文件的文字内容等；
- w (write)：可以编辑，新增或修改该文件的内容 (**但不含删除该文件**)；
- x (execute)：该文件具有可以被系统执行的权限；

2. 权限对目录的重要性

目录主要的内容在记录文件名列表，文件名与目录有强烈的关联。

- r (read contents in directory)：

表示具有读取目录结构列表的权限，所以当你具有读取一个目录的权限时，表示你可以查询该目录下的文件名数据，所以你就可以利用 ls 这个指令将该目录的内容列表显示出来。

- w (modify contents of directory)：

它表示你具有异动该目录结构列表的权限，也就是底下这些权限：

(1) 建立新的文件与目录；

(2) 删除已经存在的文件与目录 (**不论该文件的权限为何**)；

(3) 对已经存在的文件或目录进行更名； 

(4) 搬移该目录内的文件或目录的位置； 

- x (access directory)：

目录的 x 代表的是用户能否进入该目录成为工作目录。

也就是说，对一般文件来说，rwx 主要针对**文件的内容**来设计权限，对目录来说，rwx 则是针对目录内的**文件名列表**来设计权限。

如果你在某目录下不具有 x 权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何指令，即使你具有该目录的 r 或 w 权限。

要开放目录给任何人浏览时，应该至少也要给予 r 及 x 的权限，但 w 权限不可随便给。

## 5.2.4 Linux 文件种类与扩展名

1. 正规文件 (regular file)：

就是一般我们在进行存取的类型的文件，在由 ls -al 所显示出来的属性方面，第一个字符为 -。另外，依照文件的内容，又大略可以分为：

- 纯文本文档；
- 二进制文件；
- 数据格式文件：有些程序在运作的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 (data file)；

2. 目录 (directory)
3. 连结档 (link)

就是类似 Windows 下的快捷方式，第一个属性为 l。

4. 设备与装置文件 (device)

与系统周边及储存等相关的一些文件，通常都集中在 /dev 这个目录下。

5. 资料接口文件 (sockets)

这种类型的文件通常被用在网络上的数据承接。第一个属性为 s。

7. 数据输送文件 (FIFO, pipe)

FIFO 也是一种特殊的文件类型，它主要的目的在解决多个程序同时存取一个文件所造成的错误问题。第一个属性为 p。

## 5.3.1 Linux 目录配置的依据

FHS (Filesystem Hierarchy Standard) 的主要目的是希望让使用者可以了解到已安装软件通常放置于哪个目录下，也就是说，FHS 的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。

事实上，FHS 针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：

- / (root，根目录)：与开机系统有关；
- /usr (unix software resource)：与软件安装/执行有关；
- /var (variable)：与系统运作过程有关；

1. 根目录 (/) 的意义与内容

根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。

FHS 标准建议：根目录所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。

FHS 定义出根目录下应该要有底下这些次目录存在才好：

(见 P233)

2. /usr 的意义与内容

很多读者都会误会 /usr 为user 的缩写，其实 usr 是 Unix Software Resource 的缩写，也就是 Unix 软件资源所放置的目录，而不是用户的数据。

这个目录有点类似 Windows 系统的 C:\Windows\ (当中的一部分) + C:\Program files 这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘空间。一般来说，/usr 的次目录建议有底下这些：

(见 P236)

3. /var 的意义和内容

如果 /usr 是安装时会占用较大硬盘空间的目录，那么 /var 就是在系统运作后才渐渐占用硬盘容量的目录。因为 /var 目录主要针对常态性变动的文件，包括快取 (cache)，登录档 (log file) 以及某些软件运作所产生的文件。常见的次目录有：

(见 P237)

## 5.3.3 绝对路径和相对路径

- .：代表当前的目录，也可以使用 ./ 来表示；
- ..：代表上一层目录，也可以使用 ../ 来表示；

## 5.3.4 CentOS 的观察

打印系统的相关信息：uname

## 6.1.2 目录的相关操作

.：代表此层目录；

..：代表上一层目录；

-：代表前一个工作目录；

~：代表目前用户身份所在的家目录

~account：代表 account 这个用户的家目录 (account 是个账号名称)；

1. cd (change directory，变换目录)

如果仅输入 cd，代表的就是 cd ~。

2. pwd (显示目前所在的目录)

3. mkdir (建立新目录)

我们可以利用 -m 来强制给予一个目录相关的权限。不过，如果没有给予 -m 选项时，默认新建目录的权限跟 umask 有关。

4. rmdir (删除空目录)

## 6.2.1 文件与目录的检视：ls

当你只下达 ls 时，默认显示的只有：非隐藏档的档名，以档名进行排序及文件名代表的颜色显示如此而已。蓝色显示目录，白色显示一般文件。

ll 指令相当于 ls -l。

## 6.2.2 复制，删除与移动：cp, rm, mv

1. cp (复制文件或目录)

2. rm (移除文件或目录)

```
rm -r 文件或目录
```

上面这条指令表示递归删除，常用于目录的删除。**这是非常危险的选项**！

3. mv (移动文件与目录，或更名)

## 6.2.3 取得路径的文件名和目录名称

![1554470836773](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1554470836773.png)

## 6.3 文件内容查阅

- cat：由第一行开始显示文件内容；
- tac：从最后一行开始显示，可以看出 tac 是 cat 的倒写；
- nl：显示的时候，顺道输出行号；
- more：一页一页的显示文件内容；
- less 与 more 类似，但是比 more 更好的是，他可以向前翻页；
- head：只看头几行；
- tail：只看尾巴几行；
- od：以二进制的方式读取文件内容；

### more (一页一页翻动)

在 more 这个程序的运作过程中，你有几个按键可以按的：

- 空格键 (space)：代表向下翻一页；
- Enter：代表向下翻一行；
- /字符串：向下搜寻字符串这个关键词 (重复搜寻同一个字符串，可以直接按下 n 即可)；
- :f：立刻显示出文件名以及目前显示的行数；
- q：代表立刻离开 more，不再显示该文件内容；
- b：代表往回翻页，不过这动作只对文件有用，对管线无用；

### less (一页一页翻动)

使用 less时，可以使用  Page Up 和 Page Down 等按键的功能来往前往后翻看文件。

## 6.3.5 修改文件时间或建置新档：touch

每个文件在 Linux 底下都会记录许多的时间参数，其实是有三个主要的变动时间，那么三个时间的意义是什么呢？

- modification time (mtime)：

当该文件的内容数据变更时，就会更新这个时间。内容数据指的是文件的内容，而不是文件的属性或权限。

- status time (ctime)：

当该文件的状态 (status) 改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间。

- access time (atime)：

当该文件的内容被取用时，就会更新这个读取时间。

默认情况下，ls 显示出来的是该文件的 mtime，也就是这个文件的内容上次被更动的时间。

**可以在一行指令中写入多重指令，各个指令之间以;进行分隔，这些指令可以依序执行**

touch 这个指令最常被使用的情况是：

- 建立一个空的文件；
- 将某个文件的日期修订为目前 (mtime 与 atime)；

## 6.4.1 文件预设权限：umask

umask 就是指定目前用户在建立文件或目录的时候的权限默认值。

它的指定条件以底下的方式来指定：

![1554473250679](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1554473250679.png)

0022中第一组是特殊权限用的，我们先不要理他，所以先看后面三组即可。

在默认权限的属性上，目录与文件是不一样的。预设情况如下：

- 若使用者建立为文件，则预设没有 x 权限，也就是说只有 rw 这两个权限。预设权限如下：

-rw-rw-rw-

- 若用户建立为目录，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放。预设权限如下：

drwxrwxrwx

要注意的是，umask的分数指的是**该默认值需要减掉的权限**。拿上面的例子来说，因为 umask 为022，所以 user 并没有被拿掉任何权限，不过 group 和 others 的权限被拿掉了2 (也就是 w 这个权限)。

## 6.4.4 观察文件类型：file

如果你想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary 等，就可以利用 file 这个指令来检阅。

透过这个指令，我们可以简单的先判断这个文件的格式为何。

## 6.5.1 脚本文件名的搜寻

1. which (寻找执行档)

这个指令是根据 PATH 这个环境变量所规范的路径，去搜寻执行档的档名。

which 后面接的完整档名。

若加上 -a 选项，则可以列出所有的可以找到的同名执行文件，而非仅显示第一个。

## 6.5.2 文件档名的搜寻

find 虽然是很强大的搜寻指令，但时间花用的很大，因为 find 是直接搜寻硬盘。一般我们都是使用 whereis 和 locate 来检查，如果真的找不到再用 find 来搜寻。whereis 只找系统中某些特定目录底下的文件而已，locate 则是利用数据库来搜寻文件名。

1. whereis (由一些特定的目录中寻找文件文件名)

找出 ifconfig 这个档名：

````
whereis config
````

whereis 只找几个特定的目录而已，主要是针对 /bin/sbin 底下的执行档，以及 /usr/share/man 底下的 man page 文件。

2. locate/updatedb

找出系统中所有与 passwd 相关的档名，且只列出 5 个：

```
locate -l 5 passwd
```

locate 寻找的数据是由已建立的数据库 /var/lib/mlocate/ 里面的数据所搜寻到的。

因为它是经由数据库来搜寻的，而数据库的建立默认是在每天执行一次，所以当你新建立起来的文件，却还在数据库更新之前搜寻该文件，那么 locate 会告诉你找不到，因为必须要更新数据库。

输入 updatedb 手动更新数据库。

3. find

将过去系统上面24小时内有更动过内容 (mtime) 的文件列出：

```
find / -mtime 0
```

0代表目前的时间。

搜寻 /home 下属于 zq 的文件：

```
find /home -user zq
```

找出档名为 passwd 的文件：

```
find / -name passwd
```

## 10.1.5 查询指令是否为 Bash shell 的内建命令：type

查询一下 ls 这个指令是否为 bash 内建：

```
type ls
```

透过 type 这个指令我们可以知道每个指令是否为 bash 的内建指令。

## 10.1.6 指令的下达与快速编辑按钮

|      组合键       |                          功能与示范                          |
| :---------------: | :----------------------------------------------------------: |
| Ctrl + u/Ctrl + k | 分别是从光标处向前删除指令串 (Ctrl + u) 及向后删除指令串 (Ctrl + k) |
| Ctrl + a/Ctrl + e | 分别是让光标移动到整个指令串的最前面 (Ctrl + a) 或最后面 (Ctrl + e) |

## 10.2.2 变量的取用与设定：echo，变量设定规则，unset

输出环境变量 PATH 的内容：

```
echo $PATH
echo ${PATH}
```

### 变量的设定规则

1. 变量与变量内容以一个等号 = 来连结；

2. 等号两边不能直接接空格符；

3. 变量名称只能是英文字母与数字，但是开头字符不能是数字；

4. 变量内容若有空格符可以使用双引号 "" 或单引号 '' 将变量内容结合起来，但

   - 双引号内的特殊字符如 $ 等，可以保持原本的特性，如下所示：

     `var="lang is $LANG"`，则`echo $var`可得`lang is zh_TW.UTF-8`；

   - 单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示：

     `var="lang is $LANG"`，则`echo $var`可得`lang is $LANG`；

5. 可以用跳脱字符 \ 将特殊字符如 $，空格符，‘ 等变成一般字符；

6. 在一串指令的执行中，还需要借由其他额外的指令所提供的信息时，可以使用反单引号 ` 或 $。例如想要取得核心版本的设定：

   `version=${uname -r}`再`echo $version`可得`3.10.0-229.e17.x86_64`；

7. 若该变量为扩增变量内容时，可使用 ${变量名称} 累加内容，如下所示：

   `PATH="$PATH":/home/bin`或`PATH=${PATH}:/home/bin`；

8. 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量；(什么是子程序呢，就是说，在我目前这个 shell 的情况下，去启动另一个新的 shell，新的那个 shell 就是子程序。)

9. 通常大写字符为系统默认变量，自行设定变量可以使用小写字符；

10. 取消变量的方法为使用 unset。例如取消 myname 的设定：

    unset myname；

## 10.2.3 环境变量的功能

### 用 env 观察环境变量与常见环境变量说明

列出目前 shell 环境下的所有的环境变量与其内容：

```
env
```

### 用 set 观察所有变量 (含环境变量与自定义变量)

```
set
```

### export：自定义变量转成环境变量

子程序仅会继承父程序的环境变量，子程序不会继承父程序的自定义变量。

## 10.2.6 变量键盘读取、数组与宣告：read，array，declare

### read

让用户由键盘输入一内容，将该内容变成名为 atest 的变量：

```
$ read atest
This is a test
$ echo ${atest}
This is a test
```

### declare/typeset

让变量 sum 进行100+300+50的加总结果：

```
$ declare -i sum=100+300+50
$ echo ${sum}
450
```

### 数组 (array) 变量类型

在 bash 里，数组的设定方式是：

```
var[index]=content
```

## 10.2.7 与文件系统及程序的限制关系：ulimit

我们的 bash 是可以限制用户的某些系统资源的，包括可以开启的文件数量，可以使用的 CPU 时间，可以使用的内存总量等等。

列出你目前身份 (假设为一般账号) 的所有限制数据数值：

```
$ ulimit -a
```

限制用户仅能建立 10M 以下的容量的文件：

```
$ ulimit -f 10240
```

## 10.3.1 命令别名设定：alias，unalias

以 cls 指令来取代 clear 指令：

```
$ alias cls='clear'
```

取消刚才设定的 cls 别名：

```
$ unalias cls
```

## 10.2.3 历史命令：history

列出目前内存内的所有 history 记忆：

```
$ history
...
1017 man bash
1018 ll
1019 history
1020 history
...
```

列出的信息当中，共分为两栏，第一栏为该指令在这个 shell 当中的代码，另一个则是指令本身的内容。至于会显示几笔指令记录，则与 HISTSIZE 有关。

## 10.4.1 路径与指令搜寻顺序

指令运作的顺序可以这样看：

1. 以相对/绝对路径执行指令，例如 /bin/ls 或 ./ls；
2. 由 alias 找到该指令来执行；
3. 由 bash 内建的 (builtin) 指令来执行；
4. 透过 $PATH 这个变量的顺序搜寻到的第一个指令来执行；

## 10.4.3 bash 的环境配置文件

### login 与 non-login shell

- login shell：取得 bash 时需要完整的登入流程的，就称为 login shell；
- non-login shell：取得 bash 接口的方法不需要重复登入的举动。比如在你原本的 bash 环境下再次下达 bash 这个指令，没有输入账号密码，那么第二个 bash (子程序) 就是 non-login shell；

login shell 只会读取两个配置文件：

- /etc/profile：这是系统整体的设定，你最好不要修改这个文件；
- ~/.bash_profile 或 ~/.bash_login 或 ~/.profile (其实 bash 的 login shell 设定只会读取上面三个文件中的其中一个，而读取的顺序则是依照上面的顺序)：属于使用者个人设定，你要改自己的数据，就写入这里；

bash 的 login shell 情况下所读取的整体环境配置文件其实只有 /etc/profile，但是 /etc/profile 还会呼叫出其他的配置文件。

整个 login shell 的读取流程如下：

![1554542735351](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1554542735351.png)

实线的方向是主线流程，虚线的方向则是被呼叫的配置文件。从上面我们也可以清楚地知道，在 CentOS 的 login shell 环境下，最终被读取的配置文件是 ~/.bashrc 这个文件。所以，你可以将自己的偏好设定写入该文件即可。

## 10.4.4 终端机的环境设定：stty，set

bash 默认的组合键整理：

| 组合按键 |           执行结果           |
| :------: | :--------------------------: |
| Ctrl + C |        终止目前的命令        |
| Ctrl + D |        输入结束 (EOF)        |
| Ctrl + M |            Enter             |
| Ctrl + S |        暂停屏幕的输出        |
| Ctrl + Q |        恢复屏幕的输出        |
| Ctrl + U | 在提示字符下，将整列命令删除 |
| Ctrl + Z |        暂停目前的命令        |

## 10.4.5 通配符与特殊符号

bash 环境中的特殊符号整理：

| 符号  |                             意义                             |
| :---: | :----------------------------------------------------------: |
|   #   | 批注符号：这个最常被使用在 script 中，视为说明，在后的数据均不执行 |
|   \   |                           跳脱符号                           |
|  \|   |                         管线 (pipe)                          |
|   ;   |                      连续指令下达分隔符                      |
|   ~   |                         用户的家目录                         |
|   $   |                        取用变量前导符                        |
|   &   |         工作控制 (job control)：将指令变成背景下工作         |
|   !   |                      逻辑运算意义上的非                      |
|   /   |                   目录符号：路径分隔的符号                   |
| >, >> |                    数据流重导向：输出导向                    |
| <, << |                    数据流重导向：输入导向                    |
|  ''   |         单引号，不具有变量置换的功能 ($ 变为纯文本)          |
|  ""   |        双引号，具有变量置换的功能 ($ 可保留相关功能)         |
|  ``   |         两个 ` 中间为可以先执行的指令，亦可使用 ${}          |
|  ()   |                在中间为子 shell 的起始与结束                 |
|  {}   |                    在中间为命令区块的组合                    |

## 10.5.1 什么是数据流重导向

### standard output 与 standard error output

标准输出指的是指令执行所回传的正确的讯息，而标准错误输出可理解为指令执行失败后，所回传的错误讯息。

1. 标准输入 (stdin)：代码为0，使用 < 或 <<；
2. 标准输出 (stdout)：代码为1，使用 > 或 >>；
3. 标准错误输出 (stderr)：代码为2，使用 2> 或 2>>

对于 standard output 和 standard error output 来说：

- 1>：以覆盖的方法将正确的数据输出到指定的文件或装置上；

- 1>>：以累加的方法将正确的数据输出到指定的文件或装置上；

- 2>：以覆盖的方法将错误的数据输出到指定的文件或装置上；

- 2>>：以累加的方法将错误的数据输出到指定的文件或装置上；

### /dev/null 垃圾桶黑洞装置与特殊写法

将错误的数据丢弃，屏幕上显示正确的数据：

```
$ find /home -name .bashrc 2> /dev/null
```

### standard input：< 与 <<

`<` 就是将原本需要由键盘输入的数据，改由文件内容来取代的意思。

`>>`代表的是结束的输入字符的意思。例如我要用 cat 直接将输入的讯息输出到 catfile 中，且当由键盘输入 eof 时，该次输入就结束，那我可以这样做：

```
$ cat > catfile << "eof"
> This is a test.
> OK now stop
> eof	# 输入这个关键词，立刻就结束而不需要输入Ctrl+d
$ cat catfile
This is a test
OK now stop	# 只有这两行，不会存在关键词哪一行
```

## 10.5.2 命令执行的判断依据：;, &&, ||

### cmd;cmd (不考虑指令相关性的连续指令下达)

在某些时候，我们希望可以一次执行多个指令，例如在关机的时候我希望可以先执行两次 sync 同步化写入磁盘后才 shutdown 计算机，可以这样做：

```
$ sync;sync;shutdown -h now
```

### $? (指令回传值) 与 && 或 ||

|  指令下达情况  |                             说明                             |
| :------------: | :----------------------------------------------------------: |
|  cmd1 && cmd2  | 若 cmd1 执行完毕且正确执行，则开始执行 cmd2；若 cmd1 执行完毕且为错误，则 cmd2 不执行 |
| cmd1 \|\| cmd2 | 若 cmd1 执行完毕且正确执行，则 cmd2 不执行；若 cmd1 执行完毕且为错误，则开始执行 cmd2 |

## 10.6 管线命令 (pipe)

例如利用 less 查看 ls -al /etc 的内容：

```
$ ls -al /etc | less
```

- 管线命令 | 仅能处理经由前一个指令传来的正确信息，也就是 standard output 的信息，对于 standard error 并没有直接处理的能力；

- 管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行；

## 10.6.1 撷 (xie) 取命令：cut，grep

### cut

将 PATH 变量取出，找出第5个路径：

```
$ echo ${PATH} | cut -d ':' -f 5
```

cut 主要的用途在于将同一行里面的数据进行分解。

### grep

将 last 中有出现 root 的那一行取出：

```
$ last | grep 'root'
```

grep 可以解析一行文字，取得关键词，若该行有存在关键词，就会整行列出来。

## 10.6.2 排序命令：sort，uniq，wc

### sort

个人账号都记录在 /etc/passwd 下，请将账号进行排序：

```
$ cat /etc/passwd | sort
```

### uniq

使用 last 将账号列出，仅取出账号栏，进行排序后仅取出1位：

```
$ last | cut -d ' ' -f 1 | sort | uniq
```

uniq 这个指令用来将重复的行删除掉只显示一个。

### wc

那个 /etc/man_db.conf 里面到底有多少相关字、行、字符数：

```
$ cat  /etc/man_db_conf | wc
```

上面指令输出的三个数字中，分别代表：行、字数、字符数。

## 10.6.4 字符转换命令：tr，col，join，paste，expand

## 12.1.2 第一支 script 的撰写与执行

在 shell script 的撰写中还需要用到底下的注意事项：

1. 指令的执行时从上而下，从左而右的分析与执行；
2. 指令的下达：指令，选项与参数间的多个空白都会被忽略掉；
3. 空白行也将被忽略掉，并且 tab 按键所推开的空白同样视为空格键；
4. 如果读取到一个 Enter 符号，就尝试开始执行该行命令；
5. 至于如果一行的内容太多，则可以使用 \ 来延伸至下一行；
6. `#`可作为批注，任何加在`#`后面的资料将全部被视为批注文字而被忽略；

现在假设你写的这个程序文件名是 /home/zq/shell.sh，那如何执行这个文件，可以由底下几个方法：

1. 直接指令下达：shell.sh 文件必须要具备可读与可执行 (rx) 的权限，然后：
   - 绝对路径：使用 /home/zq/shell.sh 来下达指令；
   - 相对路径：假设工作目录在 /home/zq，则使用 ./shell.sh 来执行；
   - 变量 PATH 功能：将 shell.sh 放在 PATH 指定的目录内，例如 ~/bin；

2. 以 bash 程序来执行：通过 bash shell.sh 或 sh shell.sh 来执行；

### 撰写第一支 script

![1554561207238](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1554561207238.png)

1. 第一行 #!/bin/bash 在宣告这个 script 使用的 shell 的名称；
2. 程序内容的说明；

一般来说，需要说明该 script 的1. 内容与功能；2. 版本信息；3. 作者与联络方式；4. 建档日期；5. 历史记录；

3. 主要环境变量的宣告；

4. 主要程序部分；

在这个例子中，就是 echo 那一行。

5. 执行成功告知 (定义回传值)

我们可以利用 exit 这个指令来让程序中断，并且回传一个数值给系统。

## 12.3.1 利用 test 指令的测试功能

例如我要检查 /zq 是否存在时，使用：

```
$ test -e /zq
```

执行结果并不会显示任何讯息，但最后我们可以透过 $? 或 && 或 || 来展现整个结果呢，例如：

```
$ test -e /zq && echo "exist" || echo "Not exist"
Not exist
```

-e 是测试一个东西在不在，那么还有哪些标志可以来判断呢：

| 测试的标志 |              代表意义              |
| :--------: | :--------------------------------: |
|     -e     |           该档名是否存在           |
|     -f     |   该档名是否存在且为文件 (file)    |
|     -d     | 该档名是否存在且为目录 (directory) |
|    ...     |                ...                 |

(见 P543)

## 16.1.1 进程与程序 (process & program)

程序就是一个 binary file，不同的使用者身份执行这个程序时，系统给予的权限也都不相同。

![1554563364694](C:\Users\guidiao\AppData\Roaming\Typora\typora-user-images\1554563364694.png)

- 程序 (program)：通常为 binary program，放置在储存媒体中 (如硬盘，光盘，软盘，磁带等)，为实体文件的形态存在；
- 进程 (process)：程序被触发后，执行者的权限与属性，程序的程序代码与所需数据等都会被加载到内存中，操作系统给予这个内存内的单元一个标识符 (PID)。可以说，进程就是一个正在运作中的程序；

### 系统或网络服务：常驻内存的进程

常驻在内存中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻程序就会被我们称为：服务 (daemon)。

## 16.1.2 Linux 的多人多任务环境

### 特殊的进程管理行为

如果我在 Linux 下以文字界面登入，在屏幕当中显示错误讯息后就挂了，不能动了，这个时候那默认的七个窗口就帮上忙了，你可以随意的按 Alt + F1-F7 来切换到其他的终端机界面，然后以 ps -aux 找出刚刚的错误进程，然后 kill 一下，回到刚刚的终端机界面，就恢复正常了。

## 16.2 工作管理 (job control)

当我们登入系统取得 bash shell 之后，在**单一终端机接口**下同时进行多个工作的行为管理。

## 16.2.1 什么是工作管理

进行工作管理的行为中，其实每个工作都是目前 bash 的子进程，亦即彼此之间是有相关性的。我们无法以 job control 的方式由 tty1 的环境去管理 tty2 的 bash。

要进行 bash 的 jon control 必须要注意到的限制是：

- 这些工作所触发的进程必须来自于你 shell 的子进程 (只管理自己 bash)；
- 前景：你可以控制与下达指令的这个环境称为前景的工作 (foreground)；
- 背景：可以自行运作的工作，你无法使用 ctrl + c 终止它，可以使用 bg/fg 呼叫该工作；
- 背景中执行的进程不能等待 terminal/shell 的输入；

## 16.2.2 job control 的管理

### 直接将指令丢到背景中执行的 &

举个例子，我们要将 /etc/ 整个备份称为 /tmp/etc.tar.gz 且不想要等待，那么可以这样做：

```
$ tar -zpcf /tmp/etc.tar.gz /etc &
[1] 14432
...
```

在中括号内的号码为工作号码，该号码与 bash 的控制有关。

后续的14432则是这个工作在系统中的 PID。

由于我们没有加上数据流重导向，所以会影响画面，不过不会影响前景的操作。

### 将目前的工作丢到背景中暂停：ctrl + z

```
$ find /
...
# 此时屏幕会非常的忙碌，因为屏幕上会显示所有的文件名。请按下ctrl+z暂停。
[1]+ Stopped			find /
```

[1]表示这是第一个工作，而那个 + 代表最近一个被丢进背景中的工作，且目前在背景下预设会被取用的那个工作 (与 fg 这个指令有关)，而那个 Stopped 则代表目前这个工作的状态。在预设的情况下，使用 ctrl + z 丢到背景中的工作都是暂停的状态。

### 观察目前的背景工作状态：jobs

观察目前的 bash 当中，所有的工作与对应的 PID：

```
$ jobs -l
[1]- 14566 Stopped	vim ~/.bashrc
[2]+ 14567 Stopped	find / -print
```

上面表示目前我有两个工作在背景中，两个工作都是暂停的，而如果我仅输入 fg 时，那么那个 [2] 会被拿到前景当中来处理。

其实 + 代表最近被放到背景中的工作号码，- 代表最近最后第二个被放置到背景中的工作号码。而超过最后第三个以后的工作，就不会有 +/- 符号存在了。

### 将背景工作拿到前景来处理：fg

```
$ fg	# 预设取出+的工作
$ fg %1	# 取出工作号码为1的那个工作
```

### 让工作在背景下的状态变成运作中：bg

```
$ bg %3	# 让工作号码为3的工作在背景下进行
```

### 管理背景当中的工作：kill

```
$ kill -signal %jobnumber
选项与参数：
-l：列出目前kill能够使用的讯号 (signal) 有哪些；
-1：重新读取一次参数的配置文件 (类似reload)；
-2：代表由键盘出入ctrl+c同样的动作；
-9：立刻强制删除一个工作；
-15：以正常的进程方式终止一项工作。与-9是不一样的；
```

-9这个 signal 通常是用在强制删除一个不正常的工作时所使用的，-15则是以正常的步骤结束一项工作 (15也是默认值)。

## 16.2.3 脱机管理问题

要注意的是，我们在工作管理当中提到的背景指的是终端机模式下可以避免 ctrl + c 中断的一个情境，**你可以说那个是 bash 的背景，并不是放到系统的背景去**。所以工作管理的背景依旧与终端机有关。在这样的情况下，如果你是以远程联机的方式连接到你的 Linux 主机，并且将工作以 & 的方式放到背景去，请问，在工作尚未结束的情况下你脱机了，该工作还会继续进行吗？答案是否，不会继续进行，而是会被中断掉。

如果你想要让背景的工作在你注销后还能继续的执行，那么使用 nohup 搭配 & 是不错的运作情境。

## 16.3.1 进程的观察 (下面几个章节的笔记 Typora 崩溃所以弄丢了...)

### ps：将某个时间点的进程运作情况撷取下来

(见 P718)

### top：动态观察进程的变化

(见 P721)

### pstree (找进程之间的相关性)

(见 P724)

## 16.3.2 进程的管理

### kill -signal PID

(见 P726)

### kill -signal 指令名称

(见 P727)

## 16.3.3 关于进程的执行顺序

### Priority 与 Nice 值

(见 P728)

### nice：新执行的指令即给予新的 nice 值

(见 P730)

### renice：已存在进程的 nice 重新调整

(见 P730)

## 16.3.4 系统资源的观察

### free：观察内存的使用情况

(见 P731)

### netstat：追踪网络或 socket 文件

(见 P733)

### vmstat：侦测系统资源的变化

(见 P735)

## 16.6 重点回顾

- 进程 (process)：程序被触发后，执行者的权限与属性，程序的程序代码与所需数据等都会被加载到内存中，操作系统给予这个内存内的单元一个标识符 (PID)，可以说，进程就是一个正在运作中的程序；
- 进程彼此之间是有相关性的，故有父进程与子进程之分。而 Linux 系统所有进程的父进程就是 init 这个 PID 为1号的进程；
- 在 Linux 的进程呼叫通常称为 fork-and-exec 的流程。进程都会借由父进程以复制 (fork) 的方式产生一个一模一样的子进程，然后被复制出来的子进程再以 exec 的方式来执行实际要进行的程序，最终就成为一个子进程而存在；
- 常驻在内存中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻程序就会被我们称为：服务 (daemon)；
- 在工作管理 (job control)中，可以出现提示字符让你操作的环境就称为前景 (foreground)，至于其他工作就可以让你放入背景 (background) 去暂停或运作；
- 与 job control 有关的按键与关键词有：&, ctrl + z, jobs, fg, bg, kill %n 等；
- 进程管理的观察指令有：ps, top, pstree 等；
- 进程之间是可以相互控制的，传递的讯息 (signal) 主要透过 kill 这个指令在处理；
- 进程是有优先级的，该项目为 Priority，但 PRI 是核心动态调整的，用户只能使用 nice 值去微调 PRI；
- nice 的给予可以有：nice, renice, top 等；
- vmstat 为相当好用的系统资源使用情况观察指令；

